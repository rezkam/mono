// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/google/wire"
	"github.com/rezkam/mono/internal/application/auth"
	"github.com/rezkam/mono/internal/application/todo"
	"github.com/rezkam/mono/internal/config"
	"github.com/rezkam/mono/internal/http"
	"github.com/rezkam/mono/internal/http/handler"
	"github.com/rezkam/mono/internal/http/middleware"
	"github.com/rezkam/mono/internal/infrastructure/persistence/postgres"
	"os"
	"time"
)

// Injectors from wire.go:

// InitializeHTTPServer wires everything together for the HTTP server.
func InitializeHTTPServer(ctx context.Context) (*HTTPServer, func(), error) {
	serverConfig, err := config.LoadServerConfig()
	if err != nil {
		return nil, nil, err
	}
	storageConfig := &serverConfig.StorageConfig
	store, cleanup, err := provideStore(ctx, storageConfig)
	if err != nil {
		return nil, nil, err
	}
	todoConfig := provideTodoConfig()
	service := todo.NewService(store, todoConfig)
	server := handler.NewServer(service)
	duration := _wireDurationValue
	authenticator, cleanup2, err := provideAuthenticator(ctx, store, duration)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	auth := middleware.NewAuth(authenticator)
	mux := http.NewRouter(server, auth)
	httpServer := provideHTTPServer(mux, serverConfig)
	return httpServer, func() {
		cleanup2()
		cleanup()
	}, nil
}

var (
	_wireDurationValue = time.Duration(5 * time.Second)
)

// wire.go:

// ConfigSet provides configuration.
var ConfigSet = wire.NewSet(config.LoadServerConfig, wire.FieldsOf(new(*config.ServerConfig),
	"StorageConfig",
	"AuthConfig",
),
)

// DatabaseSet provides database connection and store.
// The Store implements both todo.Repository and auth.Repository
var DatabaseSet = wire.NewSet(
	provideStore, wire.Bind(new(todo.Repository), new(*postgres.Store)), wire.Bind(new(auth.Repository), new(*postgres.Store)),
)

// provideStore creates a postgres.Store from StorageConfig.
// Returns the store and a cleanup function that closes the database connection pool.
func provideStore(ctx context.Context, cfg *config.StorageConfig) (*postgres.Store, func(), error) {
	store, err := postgres.NewPostgresStore(ctx, cfg.StorageDSN)
	if err != nil {
		return nil, nil, err
	}

	cleanup := func() {
		if err := store.Close(); err != nil {
			fmt.Fprintf(os.Stderr, "failed to close database: %v\n", err)
		}
	}

	return store, cleanup, nil
}

// provideTodoConfig reads pagination config from environment.
func provideTodoConfig() todo.Config {
	defaultPageSize, _ := config.GetEnv[int]("MONO_DEFAULT_PAGE_SIZE")
	maxPageSize, _ := config.GetEnv[int]("MONO_MAX_PAGE_SIZE")

	return todo.Config{
		DefaultPageSize: defaultPageSize,
		MaxPageSize:     maxPageSize,
	}
}

// ServiceSet provides application services.
var ServiceSet = wire.NewSet(todo.NewService, provideTodoConfig)

// provideAuthenticator creates an Authenticator and returns a cleanup function
// that gracefully shuts down the background worker.
func provideAuthenticator(ctx context.Context, repo auth.Repository, timeout time.Duration) (*auth.Authenticator, func(), error) {
	authenticator := auth.NewAuthenticator(ctx, repo, timeout)

	cleanup := func() {

		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := authenticator.Shutdown(shutdownCtx); err != nil {
			fmt.Fprintf(os.Stderr, "failed to shutdown authenticator: %v\n", err)
		}
	}

	return authenticator, cleanup, nil
}

// AuthSet provides authentication components.
var AuthSet = wire.NewSet(wire.Value(time.Duration(5*time.Second)), provideAuthenticator)

// HTTPSet provides HTTP layer components.
var HTTPSet = wire.NewSet(handler.NewServer, middleware.NewAuth, http.NewRouter)
