// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"fmt"
	"github.com/google/wire"
	"github.com/rezkam/mono/internal/application/auth"
	"github.com/rezkam/mono/internal/application/todo"
	"github.com/rezkam/mono/internal/config"
	"github.com/rezkam/mono/internal/http"
	"github.com/rezkam/mono/internal/http/handler"
	"github.com/rezkam/mono/internal/http/middleware"
	"github.com/rezkam/mono/internal/infrastructure/persistence/postgres"
	"github.com/rezkam/mono/pkg/observability"
	"log/slog"
	"os"
	"time"
)

// Injectors from wire.go:

// InitializeHTTPServer wires everything together for the HTTP server.
func InitializeHTTPServer(ctx context.Context) (*HTTPServer, func(), error) {
	bool2 := provideObservabilityEnabled()
	logger, cleanup, err := provideObservability(ctx, bool2)
	if err != nil {
		return nil, nil, err
	}
	serverConfig, err := config.LoadServerConfig()
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	storageConfig := &serverConfig.StorageConfig
	dbConfig := provideDBConfig()
	store, cleanup2, err := provideStore(ctx, logger, storageConfig, dbConfig)
	if err != nil {
		cleanup()
		return nil, nil, err
	}
	todoConfig := provideTodoConfig()
	service := todo.NewService(store, todoConfig)
	server := handler.NewServer(service)
	authConfig := provideAuthConfig()
	authenticator, cleanup3, err := provideAuthenticator(ctx, store, authConfig)
	if err != nil {
		cleanup2()
		cleanup()
		return nil, nil, err
	}
	auth := middleware.NewAuth(authenticator)
	mux := http.NewRouter(server, auth)
	httpServerConfig := provideHTTPServerConfig()
	httpServer := provideHTTPServer(mux, logger, httpServerConfig)
	return httpServer, func() {
		cleanup3()
		cleanup2()
		cleanup()
	}, nil
}

// wire.go:

// ConfigSet provides configuration.
var ConfigSet = wire.NewSet(config.LoadServerConfig, wire.FieldsOf(new(*config.ServerConfig),
	"StorageConfig",
),
)

// DatabaseSet provides database connection and store.
// The Store implements both todo.Repository and auth.Repository
var DatabaseSet = wire.NewSet(
	provideDBConfig,
	provideStore, wire.Bind(new(todo.Repository), new(*postgres.Store)), wire.Bind(new(auth.Repository), new(*postgres.Store)),
)

// provideDBConfig reads database pool config from environment.
func provideDBConfig() postgres.DBConfig {
	maxOpenConns, _ := config.GetEnv[int]("MONO_DB_MAX_OPEN_CONNS")
	maxIdleConns, _ := config.GetEnv[int]("MONO_DB_MAX_IDLE_CONNS")
	connMaxLifetimeSec, _ := config.GetEnv[int]("MONO_DB_CONN_MAX_LIFETIME_SEC")
	connMaxIdleTimeSec, _ := config.GetEnv[int]("MONO_DB_CONN_MAX_IDLE_TIME_SEC")

	return postgres.DBConfig{
		MaxOpenConns:    maxOpenConns,
		MaxIdleConns:    maxIdleConns,
		ConnMaxLifetime: time.Duration(connMaxLifetimeSec) * time.Second,
		ConnMaxIdleTime: time.Duration(connMaxIdleTimeSec) * time.Second,
	}
}

// provideStore creates a postgres.Store from StorageConfig and DBConfig.
// Returns the store and a cleanup function that closes the database connection pool.
func provideStore(ctx context.Context, logger *slog.Logger, cfg *config.StorageConfig, dbCfg postgres.DBConfig) (*postgres.Store, func(), error) {
	dbCfg.DSN = cfg.StorageDSN
	store, err := postgres.NewStoreWithConfig(ctx, dbCfg)
	if err != nil {
		return nil, nil, err
	}

	cleanup := func() {
		if err := store.Close(); err != nil {
			fmt.Fprintf(os.Stderr, "failed to close database: %v\n", err)
		}
	}

	return store, cleanup, nil
}

// provideTodoConfig reads pagination config from environment.
func provideTodoConfig() todo.Config {
	defaultPageSize, _ := config.GetEnv[int]("MONO_DEFAULT_PAGE_SIZE")
	maxPageSize, _ := config.GetEnv[int]("MONO_MAX_PAGE_SIZE")

	return todo.Config{
		DefaultPageSize: defaultPageSize,
		MaxPageSize:     maxPageSize,
	}
}

// ServiceSet provides application services.
var ServiceSet = wire.NewSet(todo.NewService, provideTodoConfig)

// provideAuthConfig reads authenticator config from environment.
func provideAuthConfig() auth.Config {
	operationTimeoutSec, _ := config.GetEnv[int]("MONO_AUTH_OPERATION_TIMEOUT_SEC")
	updateQueueSize, _ := config.GetEnv[int]("MONO_AUTH_UPDATE_QUEUE_SIZE")

	return auth.Config{
		OperationTimeout: time.Duration(operationTimeoutSec) * time.Second,
		UpdateQueueSize:  updateQueueSize,
	}
}

// provideAuthenticator creates an Authenticator and returns a cleanup function
// that gracefully shuts down the background worker.
func provideAuthenticator(ctx context.Context, repo auth.Repository, cfg auth.Config) (*auth.Authenticator, func(), error) {
	authenticator := auth.NewAuthenticator(ctx, repo, cfg)

	cleanup := func() {

		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := authenticator.Shutdown(shutdownCtx); err != nil {
			fmt.Fprintf(os.Stderr, "failed to shutdown authenticator: %v\n", err)
		}
	}

	return authenticator, cleanup, nil
}

// AuthSet provides authentication components.
var AuthSet = wire.NewSet(
	provideAuthConfig,
	provideAuthenticator,
)

// provideObservabilityEnabled reads MONO_OTEL_ENABLED from environment.
func provideObservabilityEnabled() bool {
	enabled, exists := config.GetEnv[bool]("MONO_OTEL_ENABLED")
	if !exists {
		return false
	}
	return enabled
}

// provideObservability initializes OpenTelemetry providers and returns cleanup function.
func provideObservability(ctx context.Context, enabled bool) (*slog.Logger, func(), error) {

	tracerProvider, err := observability.InitTracerProvider(ctx, enabled)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to init tracer provider: %w", err)
	}

	meterProvider, err := observability.InitMeterProvider(ctx, enabled)
	if err != nil {
		tracerProvider.Shutdown(ctx)
		return nil, nil, fmt.Errorf("failed to init meter provider: %w", err)
	}

	loggerProvider, logger, err := observability.InitLogger(ctx, enabled)
	if err != nil {
		meterProvider.Shutdown(ctx)
		tracerProvider.Shutdown(ctx)
		return nil, nil, fmt.Errorf("failed to init logger: %w", err)
	}
	slog.SetDefault(logger)

	cleanup := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()

		if err := loggerProvider.Shutdown(shutdownCtx); err != nil {
			fmt.Fprintf(os.Stderr, "failed to shutdown logger provider: %v\n", err)
		}
		if err := meterProvider.Shutdown(shutdownCtx); err != nil {
			fmt.Fprintf(os.Stderr, "failed to shutdown meter provider: %v\n", err)
		}
		if err := tracerProvider.Shutdown(shutdownCtx); err != nil {
			fmt.Fprintf(os.Stderr, "failed to shutdown tracer provider: %v\n", err)
		}
	}

	return logger, cleanup, nil
}

// ObservabilitySet provides observability components.
var ObservabilitySet = wire.NewSet(
	provideObservabilityEnabled,
	provideObservability,
)

// HTTPSet provides HTTP layer components.
var HTTPSet = wire.NewSet(handler.NewServer, middleware.NewAuth, http.NewRouter, provideHTTPServerConfig,
	provideHTTPServer,
)
