// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: cron_leases.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredLeases = `-- name: CleanupExpiredLeases :execrows
DELETE FROM cron_job_leases
WHERE expires_at <= NOW()
`

// Remove expired leases (housekeeping).
func (q *Queries) CleanupExpiredLeases(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, cleanupExpiredLeases)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getLease = `-- name: GetLease :one
SELECT run_type, holder_id, acquired_at, expires_at, renewed_at, run_count FROM cron_job_leases
WHERE run_type = $1
`

// Retrieve the current lease holder for a run type.
func (q *Queries) GetLease(ctx context.Context, runType string) (CronJobLease, error) {
	row := q.db.QueryRow(ctx, getLease, runType)
	var i CronJobLease
	err := row.Scan(
		&i.RunType,
		&i.HolderID,
		&i.AcquiredAt,
		&i.ExpiresAt,
		&i.RenewedAt,
		&i.RunCount,
	)
	return i, err
}

const releaseLease = `-- name: ReleaseLease :execrows
DELETE FROM cron_job_leases
WHERE run_type = $1 AND holder_id = $2
`

type ReleaseLeaseParams struct {
	RunType  string `json:"run_type"`
	HolderID string `json:"holder_id"`
}

// Release a lease held by the specified holder.
// Only succeeds if the lease is currently held by this holder.
func (q *Queries) ReleaseLease(ctx context.Context, arg ReleaseLeaseParams) (int64, error) {
	result, err := q.db.Exec(ctx, releaseLease, arg.RunType, arg.HolderID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const renewLease = `-- name: RenewLease :execrows
UPDATE cron_job_leases
SET expires_at = $3,
    renewed_at = NOW()
WHERE run_type = $1 AND holder_id = $2
`

type RenewLeaseParams struct {
	RunType   string             `json:"run_type"`
	HolderID  string             `json:"holder_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Renew an existing lease by extending its expiration.
// Only succeeds if the lease is currently held by this holder.
func (q *Queries) RenewLease(ctx context.Context, arg RenewLeaseParams) (int64, error) {
	result, err := q.db.Exec(ctx, renewLease, arg.RunType, arg.HolderID, arg.ExpiresAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const tryAcquireLease = `-- name: TryAcquireLease :one
INSERT INTO cron_job_leases (
    run_type, holder_id, acquired_at, expires_at, renewed_at, run_count
) VALUES (
    $1, $2, NOW(), $3, NOW(), 1
)
ON CONFLICT (run_type) DO UPDATE
SET holder_id = EXCLUDED.holder_id,
    expires_at = EXCLUDED.expires_at,
    renewed_at = NOW(),
    run_count = cron_job_leases.run_count + 1
WHERE cron_job_leases.expires_at <= NOW()
   OR cron_job_leases.holder_id = EXCLUDED.holder_id
RETURNING run_type, holder_id, acquired_at, expires_at, renewed_at, run_count
`

type TryAcquireLeaseParams struct {
	RunType   string             `json:"run_type"`
	HolderID  string             `json:"holder_id"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// Atomically try to acquire or renew a lease for exclusive execution.
// Uses INSERT ON CONFLICT to handle both initial acquisition and renewal.
// Returns the lease if successfully acquired/renewed, NULL otherwise.
func (q *Queries) TryAcquireLease(ctx context.Context, arg TryAcquireLeaseParams) (CronJobLease, error) {
	row := q.db.QueryRow(ctx, tryAcquireLease, arg.RunType, arg.HolderID, arg.ExpiresAt)
	var i CronJobLease
	err := row.Scan(
		&i.RunType,
		&i.HolderID,
		&i.AcquiredAt,
		&i.ExpiresAt,
		&i.RenewedAt,
		&i.RunCount,
	)
	return i, err
}
