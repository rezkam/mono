// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dead_letter_jobs.sql

package sqlcgen

import (
	"context"
	"database/sql"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteResolvedDeadLetterJobs = `-- name: DeleteResolvedDeadLetterJobs :execrows
DELETE FROM dead_letter_jobs
WHERE resolution IS NOT NULL
  AND reviewed_at < $1
`

// Cleanup old resolved dead letter jobs (housekeeping).
// Retention period determined by caller (e.g., 30 days).
func (q *Queries) DeleteResolvedDeadLetterJobs(ctx context.Context, reviewedAt pgtype.Timestamptz) (int64, error) {
	result, err := q.db.Exec(ctx, deleteResolvedDeadLetterJobs, reviewedAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getDeadLetterJob = `-- name: GetDeadLetterJob :one
SELECT id, original_job_id, template_id, generate_from, generate_until, error_type, error_message, stack_trace, failed_at, reviewed_at, resolution, reviewed_by, reviewer_note, retry_count, last_worker_id, original_scheduled_for, original_created_at FROM dead_letter_jobs
WHERE id = $1
`

// Retrieve a specific dead letter job by ID.
func (q *Queries) GetDeadLetterJob(ctx context.Context, id pgtype.UUID) (DeadLetterJob, error) {
	row := q.db.QueryRow(ctx, getDeadLetterJob, id)
	var i DeadLetterJob
	err := row.Scan(
		&i.ID,
		&i.OriginalJobID,
		&i.TemplateID,
		&i.GenerateFrom,
		&i.GenerateUntil,
		&i.ErrorType,
		&i.ErrorMessage,
		&i.StackTrace,
		&i.FailedAt,
		&i.ReviewedAt,
		&i.Resolution,
		&i.ReviewedBy,
		&i.ReviewerNote,
		&i.RetryCount,
		&i.LastWorkerID,
		&i.OriginalScheduledFor,
		&i.OriginalCreatedAt,
	)
	return i, err
}

const insertDeadLetterJob = `-- name: InsertDeadLetterJob :exec
INSERT INTO dead_letter_jobs (
    original_job_id, template_id, generate_from, generate_until,
    error_type, error_message, stack_trace,
    retry_count, last_worker_id, original_scheduled_for, original_created_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7,
    $8, $9, $10, $11
)
`

type InsertDeadLetterJobParams struct {
	OriginalJobID        pgtype.UUID        `json:"original_job_id"`
	TemplateID           pgtype.UUID        `json:"template_id"`
	GenerateFrom         pgtype.Timestamptz `json:"generate_from"`
	GenerateUntil        pgtype.Timestamptz `json:"generate_until"`
	ErrorType            string             `json:"error_type"`
	ErrorMessage         sql.Null[string]   `json:"error_message"`
	StackTrace           sql.Null[string]   `json:"stack_trace"`
	RetryCount           int32              `json:"retry_count"`
	LastWorkerID         sql.Null[string]   `json:"last_worker_id"`
	OriginalScheduledFor pgtype.Timestamptz `json:"original_scheduled_for"`
	OriginalCreatedAt    pgtype.Timestamptz `json:"original_created_at"`
}

// Move a failed job to the dead letter queue for admin review.
func (q *Queries) InsertDeadLetterJob(ctx context.Context, arg InsertDeadLetterJobParams) error {
	_, err := q.db.Exec(ctx, insertDeadLetterJob,
		arg.OriginalJobID,
		arg.TemplateID,
		arg.GenerateFrom,
		arg.GenerateUntil,
		arg.ErrorType,
		arg.ErrorMessage,
		arg.StackTrace,
		arg.RetryCount,
		arg.LastWorkerID,
		arg.OriginalScheduledFor,
		arg.OriginalCreatedAt,
	)
	return err
}

const listPendingDeadLetterJobs = `-- name: ListPendingDeadLetterJobs :many
SELECT id, original_job_id, template_id, generate_from, generate_until, error_type, error_message, stack_trace, failed_at, reviewed_at, resolution, reviewed_by, reviewer_note, retry_count, last_worker_id, original_scheduled_for, original_created_at FROM dead_letter_jobs
WHERE resolution IS NULL
ORDER BY failed_at DESC
LIMIT $1
`

// Retrieve unresolved dead letter jobs for admin review.
// Ordered by failure time (most recent first).
func (q *Queries) ListPendingDeadLetterJobs(ctx context.Context, limit int32) ([]DeadLetterJob, error) {
	rows, err := q.db.Query(ctx, listPendingDeadLetterJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeadLetterJob{}
	for rows.Next() {
		var i DeadLetterJob
		if err := rows.Scan(
			&i.ID,
			&i.OriginalJobID,
			&i.TemplateID,
			&i.GenerateFrom,
			&i.GenerateUntil,
			&i.ErrorType,
			&i.ErrorMessage,
			&i.StackTrace,
			&i.FailedAt,
			&i.ReviewedAt,
			&i.Resolution,
			&i.ReviewedBy,
			&i.ReviewerNote,
			&i.RetryCount,
			&i.LastWorkerID,
			&i.OriginalScheduledFor,
			&i.OriginalCreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markDeadLetterAsDiscarded = `-- name: MarkDeadLetterAsDiscarded :execrows
UPDATE dead_letter_jobs
SET resolution = 'discarded',
    reviewed_at = NOW(),
    reviewed_by = $2,
    reviewer_note = $3
WHERE id = $1 AND resolution IS NULL
`

type MarkDeadLetterAsDiscardedParams struct {
	ID           pgtype.UUID      `json:"id"`
	ReviewedBy   sql.Null[string] `json:"reviewed_by"`
	ReviewerNote sql.Null[string] `json:"reviewer_note"`
}

// Mark a dead letter job as discarded with admin note.
func (q *Queries) MarkDeadLetterAsDiscarded(ctx context.Context, arg MarkDeadLetterAsDiscardedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markDeadLetterAsDiscarded, arg.ID, arg.ReviewedBy, arg.ReviewerNote)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markDeadLetterAsRetried = `-- name: MarkDeadLetterAsRetried :execrows
UPDATE dead_letter_jobs
SET resolution = 'retried',
    reviewed_at = NOW(),
    reviewed_by = $2
WHERE id = $1 AND resolution IS NULL
`

type MarkDeadLetterAsRetriedParams struct {
	ID         pgtype.UUID      `json:"id"`
	ReviewedBy sql.Null[string] `json:"reviewed_by"`
}

// Mark a dead letter job as retried by admin.
func (q *Queries) MarkDeadLetterAsRetried(ctx context.Context, arg MarkDeadLetterAsRetriedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markDeadLetterAsRetried, arg.ID, arg.ReviewedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
