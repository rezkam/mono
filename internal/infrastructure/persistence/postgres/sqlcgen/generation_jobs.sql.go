// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generation_jobs.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createGenerationJob = `-- name: CreateGenerationJob :exec
INSERT INTO recurring_generation_jobs (
    id, template_id, scheduled_for, status,
    generate_from, generate_until, created_at
) VALUES (
    $1, $2, COALESCE($3, now()), $4, $5, $6, $7
)
`

type CreateGenerationJobParams struct {
	ID            uuid.UUID   `json:"id"`
	TemplateID    uuid.UUID   `json:"template_id"`
	Column3       interface{} `json:"column_3"`
	Status        string      `json:"status"`
	GenerateFrom  time.Time   `json:"generate_from"`
	GenerateUntil time.Time   `json:"generate_until"`
	CreatedAt     time.Time   `json:"created_at"`
}

// Creates a new generation job. For immediate scheduling, pass NULL for scheduled_for
// to use the database's transaction timestamp (DEFAULT now()). This prevents clock skew
// between the application and database from making jobs temporarily unclaimable.
// For future scheduling, pass an explicit timestamp to override the default.
func (q *Queries) CreateGenerationJob(ctx context.Context, arg CreateGenerationJobParams) error {
	_, err := q.db.ExecContext(ctx, createGenerationJob,
		arg.ID,
		arg.TemplateID,
		arg.Column3,
		arg.Status,
		arg.GenerateFrom,
		arg.GenerateUntil,
		arg.CreatedAt,
	)
	return err
}

const deleteCompletedGenerationJobs = `-- name: DeleteCompletedGenerationJobs :exec
DELETE FROM recurring_generation_jobs
WHERE status = 'COMPLETED' AND completed_at < $1
`

func (q *Queries) DeleteCompletedGenerationJobs(ctx context.Context, completedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedGenerationJobs, completedAt)
	return err
}

const getGenerationJob = `-- name: GetGenerationJob :one
SELECT id, template_id, scheduled_for, started_at, completed_at, failed_at, status, error_message, retry_count, generate_from, generate_until, created_at FROM recurring_generation_jobs
WHERE id = $1
`

func (q *Queries) GetGenerationJob(ctx context.Context, id uuid.UUID) (RecurringGenerationJob, error) {
	row := q.db.QueryRowContext(ctx, getGenerationJob, id)
	var i RecurringGenerationJob
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.GenerateFrom,
		&i.GenerateUntil,
		&i.CreatedAt,
	)
	return i, err
}

const hasPendingOrRunningJob = `-- name: HasPendingOrRunningJob :one
SELECT EXISTS(
    SELECT 1 FROM recurring_generation_jobs
    WHERE template_id = $1 AND status IN ('PENDING', 'RUNNING')
) AS has_job
`

// Checks if a template already has a pending or running job to prevent duplicates.
// Returns true if such a job exists, false otherwise.
func (q *Queries) HasPendingOrRunningJob(ctx context.Context, templateID uuid.UUID) (bool, error) {
	row := q.db.QueryRowContext(ctx, hasPendingOrRunningJob, templateID)
	var has_job bool
	err := row.Scan(&has_job)
	return has_job, err
}

const listPendingGenerationJobs = `-- name: ListPendingGenerationJobs :many
SELECT id, template_id, scheduled_for, started_at, completed_at, failed_at, status, error_message, retry_count, generate_from, generate_until, created_at FROM recurring_generation_jobs
WHERE status = 'PENDING' AND scheduled_for <= $1
ORDER BY scheduled_for ASC
LIMIT $2
`

type ListPendingGenerationJobsParams struct {
	ScheduledFor time.Time `json:"scheduled_for"`
	Limit        int32     `json:"limit"`
}

func (q *Queries) ListPendingGenerationJobs(ctx context.Context, arg ListPendingGenerationJobsParams) ([]RecurringGenerationJob, error) {
	rows, err := q.db.QueryContext(ctx, listPendingGenerationJobs, arg.ScheduledFor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringGenerationJob{}
	for rows.Next() {
		var i RecurringGenerationJob
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.Status,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.GenerateFrom,
			&i.GenerateUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGenerationJobStatus = `-- name: UpdateGenerationJobStatus :execrows
UPDATE recurring_generation_jobs
SET status = $1,
    started_at = CASE WHEN $1 = 'RUNNING' THEN $2 ELSE started_at END,
    completed_at = CASE WHEN $1 = 'COMPLETED' THEN $2 ELSE completed_at END,
    failed_at = CASE WHEN $1 = 'FAILED' THEN $2 ELSE failed_at END,
    error_message = $3
WHERE id = $4
`

type UpdateGenerationJobStatusParams struct {
	Status       string         `json:"status"`
	StartedAt    sql.NullTime   `json:"started_at"`
	ErrorMessage sql.NullString `json:"error_message"`
	ID           uuid.UUID      `json:"id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 â†’ domain.ErrNotFound
//
// Eliminates two-query anti-pattern: Previously required GET to fetch retry_count, then UPDATE
// Now: retry_count preserved automatically (not in SET clause), single query updates status
// Critical for worker: Detects if job was deleted/claimed by another worker between operations
func (q *Queries) UpdateGenerationJobStatus(ctx context.Context, arg UpdateGenerationJobStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateGenerationJobStatus,
		arg.Status,
		arg.StartedAt,
		arg.ErrorMessage,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
