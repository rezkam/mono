// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generation_jobs.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgx/v5/pgtype"
)

const cancelPendingJob = `-- name: CancelPendingJob :execrows
UPDATE recurring_generation_jobs
SET status = 'cancelled'
WHERE id = $1 AND status IN ('pending', 'scheduled')
`

// Cancel a pending or scheduled job immediately.
// Returns 0 rows if job doesn't exist or is not cancellable.
func (q *Queries) CancelPendingJob(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, cancelPendingJob, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const claimNextPendingJob = `-- name: ClaimNextPendingJob :one
SELECT id, template_id, generate_from, generate_until, retry_count, scheduled_for, created_at
FROM recurring_generation_jobs
WHERE (status = 'pending' AND scheduled_for <= NOW())
   OR (status = 'running' AND available_at <= NOW())
ORDER BY scheduled_for
LIMIT 1
FOR UPDATE SKIP LOCKED
`

type ClaimNextPendingJobRow struct {
	ID            string    `json:"id"`
	TemplateID    string    `json:"template_id"`
	GenerateFrom  time.Time `json:"generate_from"`
	GenerateUntil time.Time `json:"generate_until"`
	RetryCount    int32     `json:"retry_count"`
	ScheduledFor  time.Time `json:"scheduled_for"`
	CreatedAt     time.Time `json:"created_at"`
}

// Atomically claim the next pending or stuck running job using SKIP LOCKED.
// Returns the job if claimed, or NULL if no jobs available.
// This query covers two scenarios:
//  1. Pending jobs ready to run (scheduled_for <= NOW)
//  2. Running jobs past availability timeout (stuck workers)
func (q *Queries) ClaimNextPendingJob(ctx context.Context) (ClaimNextPendingJobRow, error) {
	row := q.db.QueryRow(ctx, claimNextPendingJob)
	var i ClaimNextPendingJobRow
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.GenerateFrom,
		&i.GenerateUntil,
		&i.RetryCount,
		&i.ScheduledFor,
		&i.CreatedAt,
	)
	return i, err
}

const completeJobWithOwnershipCheck = `-- name: CompleteJobWithOwnershipCheck :execrows
UPDATE recurring_generation_jobs
SET status = 'completed',
    completed_at = NOW(),
    claimed_by = NULL,
    claimed_at = NULL,
    available_at = NOW()
WHERE id = $1 AND claimed_by = $2
`

type CompleteJobWithOwnershipCheckParams struct {
	ID        string           `json:"id"`
	ClaimedBy sql.Null[string] `json:"claimed_by"`
}

// Mark job as completed, but only if still owned by the specified worker.
// Returns 0 rows if job doesn't exist or ownership was lost.
// Note: available_at is set to completed_at since NOT NULL constraint prevents NULL.
func (q *Queries) CompleteJobWithOwnershipCheck(ctx context.Context, arg CompleteJobWithOwnershipCheckParams) (int64, error) {
	result, err := q.db.Exec(ctx, completeJobWithOwnershipCheck, arg.ID, arg.ClaimedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const discardJobAfterMaxRetries = `-- name: DiscardJobAfterMaxRetries :execrows
UPDATE recurring_generation_jobs
SET status = 'discarded',
    retry_count = $2,
    error_message = $3,
    failed_at = NOW()
WHERE id = $1
`

type DiscardJobAfterMaxRetriesParams struct {
	ID           string           `json:"id"`
	RetryCount   int32            `json:"retry_count"`
	ErrorMessage sql.Null[string] `json:"error_message"`
}

// Move job to discarded state after exhausting retries.
func (q *Queries) DiscardJobAfterMaxRetries(ctx context.Context, arg DiscardJobAfterMaxRetriesParams) (int64, error) {
	result, err := q.db.Exec(ctx, discardJobAfterMaxRetries, arg.ID, arg.RetryCount, arg.ErrorMessage)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const discardJobWithOwnershipCheck = `-- name: DiscardJobWithOwnershipCheck :execrows
UPDATE recurring_generation_jobs
SET status = 'discarded',
    error_message = $3,
    failed_at = NOW(),
    claimed_by = NULL,
    claimed_at = NULL,
    available_at = NOW()
WHERE id = $1 AND claimed_by = $2
`

type DiscardJobWithOwnershipCheckParams struct {
	ID           string           `json:"id"`
	ClaimedBy    sql.Null[string] `json:"claimed_by"`
	ErrorMessage sql.Null[string] `json:"error_message"`
}

// Mark job as discarded with ownership verification.
// Used by MoveToDeadLetter for atomic DLQ + discard operation.
// Returns 0 rows if job doesn't exist or ownership was lost.
func (q *Queries) DiscardJobWithOwnershipCheck(ctx context.Context, arg DiscardJobWithOwnershipCheckParams) (int64, error) {
	result, err := q.db.Exec(ctx, discardJobWithOwnershipCheck, arg.ID, arg.ClaimedBy, arg.ErrorMessage)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const extendJobAvailability = `-- name: ExtendJobAvailability :execrows
UPDATE recurring_generation_jobs
SET available_at = $3
WHERE id = $1 AND claimed_by = $2 AND status = 'running'
`

type ExtendJobAvailabilityParams struct {
	ID          string             `json:"id"`
	ClaimedBy   sql.Null[string]   `json:"claimed_by"`
	AvailableAt pgtype.Timestamptz `json:"available_at"`
}

// Extend the availability timeout for a running job (heartbeat).
// Only succeeds if job is still owned by the specified worker.
func (q *Queries) ExtendJobAvailability(ctx context.Context, arg ExtendJobAvailabilityParams) (int64, error) {
	result, err := q.db.Exec(ctx, extendJobAvailability, arg.ID, arg.ClaimedBy, arg.AvailableAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findGenerationJobByID = `-- name: FindGenerationJobByID :one
SELECT id, template_id, status, available_at, claimed_by, claimed_at, generate_from, generate_until, scheduled_for, created_at, started_at, completed_at, failed_at, error_message, retry_count FROM recurring_generation_jobs
WHERE id = $1
`

// Retrieve a generation job by ID
func (q *Queries) FindGenerationJobByID(ctx context.Context, id string) (RecurringGenerationJob, error) {
	row := q.db.QueryRow(ctx, findGenerationJobByID, id)
	var i RecurringGenerationJob
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.Status,
		&i.AvailableAt,
		&i.ClaimedBy,
		&i.ClaimedAt,
		&i.GenerateFrom,
		&i.GenerateUntil,
		&i.ScheduledFor,
		&i.CreatedAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.ErrorMessage,
		&i.RetryCount,
	)
	return i, err
}

const hasPendingOrRunningJob = `-- name: HasPendingOrRunningJob :one
SELECT EXISTS (
    SELECT 1 FROM recurring_generation_jobs
    WHERE template_id = $1
      AND status IN ('pending', 'scheduled', 'running')
)
`

// Check if a template has any pending, running, or scheduled job.
// Used to prevent duplicate job creation.
func (q *Queries) HasPendingOrRunningJob(ctx context.Context, templateID string) (bool, error) {
	row := q.db.QueryRow(ctx, hasPendingOrRunningJob, templateID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const insertGenerationJob = `-- name: InsertGenerationJob :exec

INSERT INTO recurring_generation_jobs (
    id, template_id, generate_from, generate_until,
    scheduled_for, status, retry_count, created_at
) VALUES (
    $1, $2, $3, $4,
    $5, $6, $7, $8
)
`

type InsertGenerationJobParams struct {
	ID            string    `json:"id"`
	TemplateID    string    `json:"template_id"`
	GenerateFrom  time.Time `json:"generate_from"`
	GenerateUntil time.Time `json:"generate_until"`
	ScheduledFor  time.Time `json:"scheduled_for"`
	Status        string    `json:"status"`
	RetryCount    int32     `json:"retry_count"`
	CreatedAt     time.Time `json:"created_at"`
}

// Generation Job Queue - Timestamp Fields Explained
// ====================================================
// scheduled_for: WHEN the job should execute (user's intent)
//   - Set at creation or retry scheduling
//   - Determines job ordering (earliest scheduled_for processed first)
//   - For pending jobs: must be <= NOW() to be claimable
//
// available_at: WHEN the job can be claimed by workers (availability window)
//   - For pending jobs: equals scheduled_for (immediately available when scheduled)
//   - For running jobs: NOW() + timeout (e.g., 5 minutes visibility window)
//   - Enables stuck job recovery: if worker crashes, job becomes claimable when available_at <= NOW()
//   - Pattern inspired by SQS Visibility Timeout
//
// Example timeline:
//
//	T+0s:  Job created with scheduled_for=NOW(), available_at=NOW()
//	T+1s:  Worker claims job â†’ status='running', available_at=NOW()+5min
//	T+301s: Worker crashes (doesn't complete or extend)
//	T+301s: Job becomes claimable again (available_at <= NOW())
//
// Insert a single generation job
func (q *Queries) InsertGenerationJob(ctx context.Context, arg InsertGenerationJobParams) error {
	_, err := q.db.Exec(ctx, insertGenerationJob,
		arg.ID,
		arg.TemplateID,
		arg.GenerateFrom,
		arg.GenerateUntil,
		arg.ScheduledFor,
		arg.Status,
		arg.RetryCount,
		arg.CreatedAt,
	)
	return err
}

const markJobAsCancelled = `-- name: MarkJobAsCancelled :execrows
UPDATE recurring_generation_jobs
SET status = 'cancelled',
    claimed_by = NULL,
    claimed_at = NULL,
    available_at = NOW()
WHERE id = $1 AND status = 'cancelling' AND claimed_by = $2
`

type MarkJobAsCancelledParams struct {
	ID        string           `json:"id"`
	ClaimedBy sql.Null[string] `json:"claimed_by"`
}

// Final cancellation by worker after cooperative shutdown.
// Note: available_at is set to NOW() since NOT NULL constraint prevents NULL.
func (q *Queries) MarkJobAsCancelled(ctx context.Context, arg MarkJobAsCancelledParams) (int64, error) {
	result, err := q.db.Exec(ctx, markJobAsCancelled, arg.ID, arg.ClaimedBy)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markJobAsRunning = `-- name: MarkJobAsRunning :execrows
UPDATE recurring_generation_jobs
SET status = 'running',
    started_at = NOW(),
    claimed_by = $2,
    claimed_at = NOW(),
    available_at = $3
WHERE id = $1
`

type MarkJobAsRunningParams struct {
	ID          string             `json:"id"`
	ClaimedBy   sql.Null[string]   `json:"claimed_by"`
	AvailableAt pgtype.Timestamptz `json:"available_at"`
}

// Mark a claimed job as running with worker ownership and availability timeout.
// Returns 0 rows if job doesn't exist or was already claimed by another worker.
func (q *Queries) MarkJobAsRunning(ctx context.Context, arg MarkJobAsRunningParams) (int64, error) {
	result, err := q.db.Exec(ctx, markJobAsRunning, arg.ID, arg.ClaimedBy, arg.AvailableAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const requestCancellationForRunningJob = `-- name: RequestCancellationForRunningJob :execrows
UPDATE recurring_generation_jobs
SET status = 'cancelling'
WHERE id = $1 AND status = 'running'
`

// Request cancellation for a running job (sets cancelling status).
// Worker must cooperatively stop processing when it sees this status.
func (q *Queries) RequestCancellationForRunningJob(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, requestCancellationForRunningJob, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const scheduleJobRetry = `-- name: ScheduleJobRetry :execrows
UPDATE recurring_generation_jobs
SET status = 'pending',
    retry_count = $2,
    error_message = $3,
    scheduled_for = $4,
    failed_at = NOW(),
    claimed_by = NULL,
    claimed_at = NULL,
    available_at = $4  -- Match scheduled_for: job available when scheduled (not before due to backoff)
WHERE id = $1 AND claimed_by = $5
`

type ScheduleJobRetryParams struct {
	ID           string           `json:"id"`
	RetryCount   int32            `json:"retry_count"`
	ErrorMessage sql.Null[string] `json:"error_message"`
	ScheduledFor time.Time        `json:"scheduled_for"`
	ClaimedBy    sql.Null[string] `json:"claimed_by"`
}

// Reschedule job for retry with incremented retry count.
// Only succeeds if job is still owned by the specified worker.
func (q *Queries) ScheduleJobRetry(ctx context.Context, arg ScheduleJobRetryParams) (int64, error) {
	result, err := q.db.Exec(ctx, scheduleJobRetry,
		arg.ID,
		arg.RetryCount,
		arg.ErrorMessage,
		arg.ScheduledFor,
		arg.ClaimedBy,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
