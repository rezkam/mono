// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

type Querier interface {
	// Counts total matching items for pagination (used when main query returns empty page).
	// Uses same WHERE clause as ListTasksWithFilters for consistency.
	CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error)
	CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error
	// Creates a new generation job. For immediate scheduling, pass NULL for scheduled_for
	// to use the database's transaction timestamp (DEFAULT now()). This prevents clock skew
	// between the application and database from making jobs temporarily unclaimable.
	// For future scheduling, pass an explicit timestamp to override the default.
	CreateGenerationJob(ctx context.Context, arg CreateGenerationJobParams) error
	CreateRecurringTemplate(ctx context.Context, arg CreateRecurringTemplateParams) error
	CreateStatusHistoryEntry(ctx context.Context, arg CreateStatusHistoryEntryParams) error
	CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error
	CreateTodoList(ctx context.Context, arg CreateTodoListParams) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Revokes API key with existence check in single operation
	DeactivateAPIKey(ctx context.Context, id uuid.UUID) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Soft delete with existence detection in single operation
	DeactivateRecurringTemplate(ctx context.Context, arg DeactivateRecurringTemplateParams) (int64, error)
	DeleteCompletedGenerationJobs(ctx context.Context, completedAt sql.NullTime) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Hard delete with built-in existence verification
	DeleteRecurringTemplate(ctx context.Context, id uuid.UUID) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Single-query delete with existence detection built-in
	DeleteTodoItem(ctx context.Context, id uuid.UUID) (int64, error)
	DeleteTodoItemsByListId(ctx context.Context, listID uuid.UUID) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient detection of non-existent records without separate SELECT query
	DeleteTodoList(ctx context.Context, id uuid.UUID) (int64, error)
	GetAPIKeyByShortToken(ctx context.Context, shortToken string) (ApiKey, error)
	GetAllTodoItems(ctx context.Context) ([]TodoItem, error)
	GetGenerationJob(ctx context.Context, id uuid.UUID) (RecurringGenerationJob, error)
	GetRecurringTemplate(ctx context.Context, id uuid.UUID) (RecurringTaskTemplate, error)
	GetTaskStatusHistory(ctx context.Context, taskID uuid.UUID) ([]TaskStatusHistory, error)
	GetTaskStatusHistoryByDateRange(ctx context.Context, arg GetTaskStatusHistoryByDateRangeParams) ([]TaskStatusHistory, error)
	GetTodoItem(ctx context.Context, id uuid.UUID) (TodoItem, error)
	GetTodoItemsByListId(ctx context.Context, listID uuid.UUID) ([]TodoItem, error)
	GetTodoList(ctx context.Context, id uuid.UUID) (TodoList, error)
	// Checks if a template already has a pending or running job to prevent duplicates.
	// Returns true if such a job exists, false otherwise.
	HasPendingOrRunningJob(ctx context.Context, templateID uuid.UUID) (bool, error)
	ListActiveAPIKeys(ctx context.Context) ([]ApiKey, error)
	ListAllActiveRecurringTemplates(ctx context.Context) ([]RecurringTaskTemplate, error)
	ListAllRecurringTemplatesByList(ctx context.Context, listID uuid.UUID) ([]RecurringTaskTemplate, error)
	ListPendingGenerationJobs(ctx context.Context, arg ListPendingGenerationJobsParams) ([]RecurringGenerationJob, error)
	ListRecurringTemplates(ctx context.Context, listID uuid.UUID) ([]RecurringTaskTemplate, error)
	// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
	// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
	// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
	//
	// Parameters (use zero values for NULL to skip filters):
	//   $1: list_id     - Filter by specific list (zero UUID to search all lists)
	//   $2: status      - Filter by status (empty string to skip)
	//   $3: priority    - Filter by priority (empty string to skip)
	//   $4: tag         - Filter by tag (JSONB array contains, empty string to skip)
	//   $5: due_before  - Filter tasks due before timestamp (zero time to skip)
	//   $6: due_after   - Filter tasks due after timestamp (zero time to skip)
	//   $7: updated_at  - Filter by last update time (zero time to skip)
	//   $8: created_at  - Filter by creation time (zero time to skip)
	//   $9: order_by    - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
	//                     Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
	//                     For bare field names, defaults are: due_time=asc, priority=asc,
	//                     created_at=desc, updated_at=desc
	//   $10: limit      - Page size (max items to return)
	//   $11: offset     - Pagination offset (skip N items)
	//
	// Returns: All todo_items columns plus total_count (total matching rows across all pages)
	// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
	// enabling accurate pagination UI without a separate count query.
	//
	// SQL Injection Protection:
	// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
	// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
	// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
	// flows through without validation, it's compared as a string literal in CASE expressions,
	// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
	// See tests/integration/sql_injection_resistance_test.go for proof.
	//
	// Input validation at the service layer improves UX (clear error messages) but does NOT
	// provide security - parameterized queries are the security boundary.
	//
	// Access pattern example:
	//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
	//   - "Tasks in List X": filter by list_id, default sort
	//   - "High priority items": filter by priority=HIGH, order by due_time_asc
	//   - "Tasks tagged 'urgent'": filter by tag=urgent (uses GIN index)
	ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error)
	// Legacy query: Returns all lists without items (use ListTodoListsWithCounts for list views).
	ListTodoLists(ctx context.Context) ([]TodoList, error)
	// Optimized for LIST VIEW access pattern: Returns list metadata with item counts.
	// Performance: O(lists + items) with single aggregation query vs O(lists * items) loading all items.
	// Use case: Dashboard/overview pages showing list summaries without loading full item details.
	//
	// Returns:
	//   - total_items: Total count of all items in the list
	//   - undone_items: Count of active items (TODO, IN_PROGRESS, BLOCKED)
	//
	// This query uses LEFT JOIN to ensure lists with zero items still appear with count=0.
	// The FILTER clause efficiently counts only active items in a single pass.
	ListTodoListsWithCounts(ctx context.Context) ([]ListTodoListsWithCountsRow, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Updates last access timestamp with existence detection in single query
	UpdateAPIKeyLastUsed(ctx context.Context, arg UpdateAPIKeyLastUsedParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	//
	// retry_count is preserved automatically (not in SET clause)
	// Critical for worker: Detects if job was deleted/claimed by another worker between operations
	UpdateGenerationJobStatus(ctx context.Context, arg UpdateGenerationJobStatusParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) where int64 is the number of rows affected
	//
	// Why this pattern:
	//   - Single database round-trip (vs two-query SELECT+UPDATE pattern)
	//   - No race condition: record cannot be deleted between check and update
	//   - Efficient: PostgreSQL returns affected count with no additional cost
	//   - Repository layer checks: rowsAffected == 0 → domain.ErrNotFound
	//
	// Anti-pattern to avoid:
	//   SELECT to check existence, then UPDATE if found
	//   - Two round-trips to database
	//   - Race condition window between queries
	//   - Doubled network latency
	UpdateRecurringTemplate(ctx context.Context, arg UpdateRecurringTemplateParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Critical for worker: Detects if template was deleted between job claim and generation
	UpdateRecurringTemplateGenerationWindow(ctx context.Context, arg UpdateRecurringTemplateGenerationWindowParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Single database round-trip prevents race conditions and reduces latency
	// SECURITY: Validates item belongs to the specified list to prevent cross-list updates
	UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient status updates without separate existence check
	UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Avoids two-query anti-pattern (SELECT then UPDATE) with race condition and doubled latency
	// NOTE: create_time is immutable after creation - only title can be updated
	UpdateTodoList(ctx context.Context, arg UpdateTodoListParams) (int64, error)
}

var _ Querier = (*Queries)(nil)
