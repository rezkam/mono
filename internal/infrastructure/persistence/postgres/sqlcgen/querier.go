// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	// Bulk insert using PostgreSQL COPY protocol for high performance
	BatchCreateTodoItems(ctx context.Context, arg []BatchCreateTodoItemsParams) (int64, error)
	// Cancel a pending or scheduled job immediately.
	// Returns 0 rows if job doesn't exist or is not cancellable.
	CancelPendingJob(ctx context.Context, id string) (int64, error)
	// Checks if an API key exists by ID.
	// Used by UpdateLastUsed to distinguish "not found" from "timestamp not later".
	CheckAPIKeyExists(ctx context.Context, id string) (bool, error)
	// Atomically claim the next pending or stuck running job using SKIP LOCKED.
	// Returns the job if claimed, or NULL if no jobs available.
	// This query covers two scenarios:
	//   1. Pending jobs ready to run (scheduled_for <= NOW)
	//   2. Running jobs past availability timeout (stuck workers)
	ClaimNextPendingJob(ctx context.Context) (ClaimNextPendingJobRow, error)
	// Remove expired leases (housekeeping).
	CleanupExpiredLeases(ctx context.Context) (int64, error)
	// Mark job as completed, but only if still owned by the specified worker.
	// Returns 0 rows if job doesn't exist or ownership was lost.
	// Note: available_at is set to completed_at since NOT NULL constraint prevents NULL.
	CompleteJobWithOwnershipCheck(ctx context.Context, arg CompleteJobWithOwnershipCheckParams) (int64, error)
	// Counts total matching items for pagination (used when main query returns empty page).
	// Uses same WHERE clause as ListTasksWithFilters for consistency.
	// $2: statuses array (empty array skips filter, OR logic within array)
	// $3: priorities array (empty array skips filter, OR logic within array)
	// $4: tags array (empty array skips filter, item must have ALL specified tags)
	// $9: excluded_statuses array (empty array skips filter, excludes matching statuses)
	CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error)
	// Count total matching lists for pagination (same filters as FindTodoListsWithFilters).
	CountTodoListsWithFilters(ctx context.Context, arg CountTodoListsWithFiltersParams) (int32, error)
	CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error
	CreateException(ctx context.Context, arg CreateExceptionParams) (RecurringTemplateException, error)
	CreateRecurringTemplate(ctx context.Context, arg CreateRecurringTemplateParams) (RecurringTaskTemplate, error)
	CreateStatusHistoryEntry(ctx context.Context, arg CreateStatusHistoryEntryParams) error
	CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) (TodoItem, error)
	CreateTodoList(ctx context.Context, arg CreateTodoListParams) (TodoList, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Revokes API key with existence check in single operation
	DeactivateAPIKey(ctx context.Context, id string) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Soft delete with existence detection in single operation
	DeactivateRecurringTemplate(ctx context.Context, arg DeactivateRecurringTemplateParams) (int64, error)
	DeleteException(ctx context.Context, arg DeleteExceptionParams) error
	// Delete future pending items for a template (used before regeneration)
	DeleteFuturePendingItems(ctx context.Context, arg DeleteFuturePendingItemsParams) (int64, error)
	// Delete generated instances with occurs_at > NOW()
	// Used during template deletion to clean up future scheduled tasks
	// Preserves historical instances (occurs_at <= NOW()) for audit trail
	DeleteFutureRecurringInstances(ctx context.Context, templateID uuid.NullUUID) (int64, error)
	// Cleanup old resolved dead letter jobs (housekeeping).
	// Retention period determined by caller (e.g., 30 days).
	DeleteResolvedDeadLetterJobs(ctx context.Context, reviewedAt pgtype.Timestamptz) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Single-query delete with existence detection built-in
	DeleteTodoItem(ctx context.Context, id string) (int64, error)
	DeleteTodoItemsByListId(ctx context.Context, listID string) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient detection of non-existent records without separate SELECT query
	DeleteTodoList(ctx context.Context, id string) (int64, error)
	// Move job to discarded state after exhausting retries.
	DiscardJobAfterMaxRetries(ctx context.Context, arg DiscardJobAfterMaxRetriesParams) (int64, error)
	// Mark job as discarded with ownership verification.
	// Used by MoveToDeadLetter for atomic DLQ + discard operation.
	// Returns 0 rows if job doesn't exist or ownership was lost.
	DiscardJobWithOwnershipCheck(ctx context.Context, arg DiscardJobWithOwnershipCheckParams) (int64, error)
	// Extend the availability timeout for a running job (heartbeat).
	// Only succeeds if job is still owned by the specified worker.
	ExtendJobAvailability(ctx context.Context, arg ExtendJobAvailabilityParams) (int64, error)
	FindExceptionByOccurrence(ctx context.Context, arg FindExceptionByOccurrenceParams) (RecurringTemplateException, error)
	FindExceptions(ctx context.Context, arg FindExceptionsParams) ([]RecurringTemplateException, error)
	// Retrieve a generation job by ID
	FindGenerationJobByID(ctx context.Context, id string) (RecurringGenerationJob, error)
	FindRecurringTemplateByID(ctx context.Context, id string) (RecurringTaskTemplate, error)
	// Find templates needing reconciliation across all lists.
	// Used by reconciliation worker to ensure all templates are properly generated.
	// Excludes:
	//   - Templates updated after updated_before (grace period for newly created/updated)
	//   - Templates with pending/running jobs (if exclude_pending is true)
	//   - Templates already generated through their target date
	FindStaleTemplatesForReconciliation(ctx context.Context, arg FindStaleTemplatesForReconciliationParams) ([]RecurringTaskTemplate, error)
	// Advanced list query with filtering, sorting, and pagination.
	// Supports AIP-160-style filtering and AIP-132-style sorting.
	//
	// Parameters use nullable types for optional filters:
	//   - title_contains: Filters by title substring (case-insensitive)
	//   - created_at_after: Filters lists created after this time
	//   - created_at_before: Filters lists created before this time
	//   - order_by: Column to sort by ("created_at" or "title")
	//   - order_dir: Sort direction ("asc" or "desc")
	//   - page_limit: Maximum number of results to return
	//   - page_offset: Number of results to skip
	FindTodoListsWithFilters(ctx context.Context, arg FindTodoListsWithFiltersParams) ([]FindTodoListsWithFiltersRow, error)
	GetAPIKeyByShortToken(ctx context.Context, shortToken string) (ApiKey, error)
	GetAllTodoItems(ctx context.Context) ([]TodoItem, error)
	// Retrieve a specific dead letter job by ID.
	GetDeadLetterJob(ctx context.Context, id pgtype.UUID) (DeadLetterJob, error)
	// Retrieve the current lease holder for a run type.
	GetLease(ctx context.Context, runType string) (CronJobLease, error)
	GetTaskStatusHistory(ctx context.Context, taskID string) ([]TaskStatusHistory, error)
	GetTaskStatusHistoryByDateRange(ctx context.Context, arg GetTaskStatusHistoryByDateRangeParams) ([]TaskStatusHistory, error)
	GetTodoItem(ctx context.Context, id string) (TodoItem, error)
	GetTodoItemsByListId(ctx context.Context, listID string) ([]TodoItem, error)
	GetTodoList(ctx context.Context, id string) (TodoList, error)
	// Returns a single list by ID with item counts (for detail view).
	// undone_statuses parameter: domain layer defines which statuses count as "undone".
	GetTodoListWithCounts(ctx context.Context, arg GetTodoListWithCountsParams) (GetTodoListWithCountsRow, error)
	// Check if a template has any pending, running, or scheduled job.
	// Used to prevent duplicate job creation.
	HasPendingOrRunningJob(ctx context.Context, templateID string) (bool, error)
	// Move a failed job to the dead letter queue for admin review.
	InsertDeadLetterJob(ctx context.Context, arg InsertDeadLetterJobParams) error
	// Generation Job Queue - Timestamp Fields Explained
	// ====================================================
	// scheduled_for: WHEN the job should execute (user's intent)
	//   - Set at creation or retry scheduling
	//   - Determines job ordering (earliest scheduled_for processed first)
	//   - For pending jobs: must be <= NOW() to be claimable
	//
	// available_at: WHEN the job can be claimed by workers (availability window)
	//   - For pending jobs: equals scheduled_for (immediately available when scheduled)
	//   - For running jobs: NOW() + timeout (e.g., 5 minutes visibility window)
	//   - Enables stuck job recovery: if worker crashes, job becomes claimable when available_at <= NOW()
	//   - Pattern inspired by SQS Visibility Timeout
	//
	// Example timeline:
	//   T+0s:  Job created with scheduled_for=NOW(), available_at=NOW()
	//   T+1s:  Worker claims job → status='running', available_at=NOW()+5min
	//   T+301s: Worker crashes (doesn't complete or extend)
	//   T+301s: Job becomes claimable again (available_at <= NOW())
	// Insert a single generation job
	InsertGenerationJob(ctx context.Context, arg InsertGenerationJobParams) error
	// Idempotent single insert with ON CONFLICT DO NOTHING
	// Used in batch operations - duplicates silently ignored based on UNIQUE(recurring_template_id, occurs_at)
	InsertItemIgnoreConflict(ctx context.Context, arg InsertItemIgnoreConflictParams) error
	ListActiveAPIKeys(ctx context.Context) ([]ApiKey, error)
	ListAllActiveRecurringTemplates(ctx context.Context) ([]RecurringTaskTemplate, error)
	ListAllExceptionsByTemplate(ctx context.Context, templateID pgtype.UUID) ([]RecurringTemplateException, error)
	ListAllRecurringTemplatesByList(ctx context.Context, listID string) ([]RecurringTaskTemplate, error)
	// Retrieve unresolved dead letter jobs for admin review.
	// Ordered by failure time (most recent first).
	ListPendingDeadLetterJobs(ctx context.Context, limit int32) ([]DeadLetterJob, error)
	ListRecurringTemplates(ctx context.Context, listID string) ([]RecurringTaskTemplate, error)
	// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
	// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
	// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
	//
	// Parameters (use empty arrays for NULL to skip filters):
	//   $1: list_id           - Filter by specific list (zero UUID to search all lists)
	//   $2: statuses          - Array of statuses to include (empty array to skip, OR logic)
	//   $3: priorities        - Array of priorities to include (empty array to skip, OR logic)
	//   $4: tags              - Array of tags to match (empty array to skip, item must have ALL tags)
	//   $5: due_before        - Filter tasks due before timestamp (zero time to skip)
	//   $6: due_after         - Filter tasks due after timestamp (zero time to skip)
	//   $7: updated_at        - Filter by last update time (zero time to skip)
	//   $8: created_at        - Filter by creation time (zero time to skip)
	//   $9: order_by          - Combined field+direction: 'due_at_asc', 'due_at_desc', etc.
	//                           Supports: due_at, priority, created_at, updated_at with _asc or _desc suffix
	//                           For bare field names, defaults are: due_at=asc, priority=asc,
	//                           created_at=desc, updated_at=desc
	//   $10: limit            - Page size (max items to return)
	//   $11: offset           - Pagination offset (skip N items)
	//   $12: excluded_statuses - Array of statuses to exclude (empty array to skip filter)
	//                           Used to exclude archived/cancelled by default when $2 is empty
	//
	// Returns: All todo_items columns plus total_count (total matching rows across all pages)
	// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
	// enabling accurate pagination UI without a separate count query.
	//
	// SQL Injection Protection:
	// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
	// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
	// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
	// flows through without validation, it's compared as a string literal in CASE expressions,
	// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
	// See tests/integration/sql_injection_resistance_test.go for proof.
	//
	// Input validation at the service layer improves UX (clear error messages) but does NOT
	// provide security - parameterized queries are the security boundary.
	//
	// Access pattern examples:
	//   - "Show my overdue tasks": filter by due_before=now, order by due_at_asc
	//   - "Active work": statuses=[todo, in_progress], default sort
	//   - "High priority items": priorities=[high, urgent], order by due_at_asc
	//   - "Tasks tagged 'urgent' and 'work'": tags=[urgent, work] (item must have both)
	ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error)
	// Legacy query: Returns all lists without items (use ListTodoListsWithCounts for list views).
	ListTodoLists(ctx context.Context) ([]TodoList, error)
	// Optimized for LIST VIEW access pattern: Returns list metadata with item counts.
	// Performance: O(lists + items) with single aggregation query vs O(lists * items) loading all items.
	// Use case: Dashboard/overview pages showing list summaries without loading full item details.
	//
	// Returns:
	//   - total_items: Total count of all items in the list
	//   - undone_items: Count of items matching provided statuses (domain defines "undone")
	//
	// This query uses LEFT JOIN to ensure lists with zero items still appear with count=0.
	// The FILTER clause efficiently counts only matching items in a single pass.
	ListTodoListsWithCounts(ctx context.Context, undoneStatuses []string) ([]ListTodoListsWithCountsRow, error)
	// Mark a dead letter job as discarded with admin note.
	MarkDeadLetterAsDiscarded(ctx context.Context, arg MarkDeadLetterAsDiscardedParams) (int64, error)
	// Mark a dead letter job as retried by admin.
	MarkDeadLetterAsRetried(ctx context.Context, arg MarkDeadLetterAsRetriedParams) (int64, error)
	// Final cancellation by worker after cooperative shutdown.
	// Note: available_at is set to NOW() since NOT NULL constraint prevents NULL.
	MarkJobAsCancelled(ctx context.Context, arg MarkJobAsCancelledParams) (int64, error)
	// Mark a claimed job as running with worker ownership and availability timeout.
	// Returns 0 rows if job doesn't exist or was already claimed by another worker.
	MarkJobAsRunning(ctx context.Context, arg MarkJobAsRunningParams) (int64, error)
	// Release a lease held by the specified holder.
	// Only succeeds if the lease is currently held by this holder.
	ReleaseLease(ctx context.Context, arg ReleaseLeaseParams) (int64, error)
	// Renew an existing lease by extending its expiration.
	// Only succeeds if the lease is currently held by this holder.
	RenewLease(ctx context.Context, arg RenewLeaseParams) (int64, error)
	// Request cancellation for a running job (sets cancelling status).
	// Worker must cooperatively stop processing when it sees this status.
	RequestCancellationForRunningJob(ctx context.Context, id string) (int64, error)
	// Reschedule job for retry with incremented retry count.
	// Only succeeds if job is still owned by the specified worker.
	ScheduleJobRetry(ctx context.Context, arg ScheduleJobRetryParams) (int64, error)
	SetGeneratedThrough(ctx context.Context, arg SetGeneratedThroughParams) (int64, error)
	// Atomically try to acquire or renew a lease for exclusive execution.
	// Uses INSERT ON CONFLICT to handle both initial acquisition and renewal.
	// Returns the lease if successfully acquired/renewed, NULL otherwise.
	TryAcquireLease(ctx context.Context, arg TryAcquireLeaseParams) (CronJobLease, error)
	// Updates last_used_at only if the new timestamp is later than the current value.
	// Returns 0 rows affected if: (1) key doesn't exist, OR (2) timestamp not later.
	// Repository uses CheckAPIKeyExists to distinguish these cases.
	UpdateAPIKeyLastUsed(ctx context.Context, arg UpdateAPIKeyLastUsedParams) (int64, error)
	// Field mask pattern with optimistic locking support
	UpdateRecurringTemplate(ctx context.Context, arg UpdateRecurringTemplateParams) (RecurringTaskTemplate, error)
	// DATA ACCESS PATTERN: Partial update with explicit flags
	// Supports field masks by passing boolean flags for fields to update
	// Returns updated row, or pgx.ErrNoRows if:
	//   - Item doesn't exist
	//   - Item belongs to different list (security: prevents cross-list updates)
	//   - Version mismatch (concurrency: prevents lost updates)
	// SECURITY: Validates item belongs to the specified list
	// CONCURRENCY: Optional version check for optimistic locking
	// TYPE SAFETY: All fields managed by sqlc - schema changes caught at compile time
	UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (TodoItem, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient status updates without separate existence check
	UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error)
	// ATOMIC UPDATE WITH COUNTS: Uses CTE to update and return counts in single statement.
	// Prevents race conditions where counts could change between UPDATE and SELECT.
	//
	// FIELD MASK PATTERN: Selective field updates with CASE expressions
	// Only updates fields where set_<field> = true (field mask support)
	// CONCURRENCY: Optional version check for optimistic locking
	// Returns no rows if:
	//   - List doesn't exist
	//   - Version mismatch (when expected_version provided)
	UpdateTodoList(ctx context.Context, arg UpdateTodoListParams) (UpdateTodoListRow, error)
}

var _ Querier = (*Queries)(nil)
