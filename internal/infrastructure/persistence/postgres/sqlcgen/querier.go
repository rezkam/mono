// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"time"

	"context"
	"database/sql"
)

type Querier interface {
	// Bulk insert using PostgreSQL's COPY protocol.
	// This bypasses:
	//   - Query parsing per row
	//   - Planner overhead per row
	//   - Network round trips per row
	// Result: ~10x performance for batch operations (30-90 items → single operation).
	BatchCreateTodoItems(ctx context.Context, arg []BatchCreateTodoItemsParams) (int64, error)
	// Checks if an API key exists by ID.
	// Used by UpdateLastUsed to distinguish "not found" from "timestamp not later".
	CheckAPIKeyExists(ctx context.Context, id string) (bool, error)
	// Counts total matching items for pagination (used when main query returns empty page).
	// Uses same WHERE clause as ListTasksWithFilters for consistency.
	// $2: statuses array (empty array skips filter, OR logic within array)
	// $3: priorities array (empty array skips filter, OR logic within array)
	// $4: tags array (empty array skips filter, item must have ALL specified tags)
	// $9: excluded_statuses array (empty array skips filter, excludes matching statuses)
	CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error)
	// Count total matching lists for pagination (same filters as FindTodoListsWithFilters).
	CountTodoListsWithFilters(ctx context.Context, arg CountTodoListsWithFiltersParams) (int32, error)
	CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error
	// Creates a new generation job. For immediate scheduling, pass NULL for scheduled_for
	// to use the database's transaction timestamp (DEFAULT now()). This prevents clock skew
	// between the application and database from making jobs temporarily unclaimable.
	// For future scheduling, pass an explicit timestamp to override the default.
	CreateGenerationJob(ctx context.Context, arg CreateGenerationJobParams) error
	CreateRecurringTemplate(ctx context.Context, arg CreateRecurringTemplateParams) (RecurringTaskTemplate, error)
	CreateStatusHistoryEntry(ctx context.Context, arg CreateStatusHistoryEntryParams) error
	CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) (TodoItem, error)
	CreateTodoList(ctx context.Context, arg CreateTodoListParams) (TodoList, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Revokes API key with existence check in single operation
	DeactivateAPIKey(ctx context.Context, id string) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Soft delete with existence detection in single operation
	DeactivateRecurringTemplate(ctx context.Context, arg DeactivateRecurringTemplateParams) (int64, error)
	DeleteCompletedGenerationJobs(ctx context.Context, completedAt sql.Null[time.Time]) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Hard delete with built-in existence verification
	DeleteRecurringTemplate(ctx context.Context, id string) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Single-query delete with existence detection built-in
	DeleteTodoItem(ctx context.Context, id string) (int64, error)
	DeleteTodoItemsByListId(ctx context.Context, listID string) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient detection of non-existent records without separate SELECT query
	DeleteTodoList(ctx context.Context, id string) (int64, error)
	// Advanced list query with filtering, sorting, and pagination.
	// Supports AIP-160-style filtering and AIP-132-style sorting.
	//
	// Parameters use nullable types for optional filters:
	//   - title_contains: Filters by title substring (case-insensitive)
	//   - create_time_after: Filters lists created after this time
	//   - create_time_before: Filters lists created before this time
	//   - order_by: Column to sort by ("create_time" or "title")
	//   - order_dir: Sort direction ("asc" or "desc")
	//   - page_limit: Maximum number of results to return
	//   - page_offset: Number of results to skip
	FindTodoListsWithFilters(ctx context.Context, arg FindTodoListsWithFiltersParams) ([]FindTodoListsWithFiltersRow, error)
	GetAPIKeyByShortToken(ctx context.Context, shortToken string) (ApiKey, error)
	GetAllTodoItems(ctx context.Context) ([]TodoItem, error)
	GetGenerationJob(ctx context.Context, id string) (RecurringGenerationJob, error)
	GetRecurringTemplate(ctx context.Context, id string) (RecurringTaskTemplate, error)
	GetTaskStatusHistory(ctx context.Context, taskID string) ([]TaskStatusHistory, error)
	GetTaskStatusHistoryByDateRange(ctx context.Context, arg GetTaskStatusHistoryByDateRangeParams) ([]TaskStatusHistory, error)
	GetTodoItem(ctx context.Context, id string) (TodoItem, error)
	GetTodoItemsByListId(ctx context.Context, listID string) ([]TodoItem, error)
	GetTodoList(ctx context.Context, id string) (TodoList, error)
	// Returns a single list by ID with item counts (for detail view).
	// undone_statuses parameter: domain layer defines which statuses count as "undone".
	GetTodoListWithCounts(ctx context.Context, arg GetTodoListWithCountsParams) (GetTodoListWithCountsRow, error)
	// Checks if a template already has a pending or running job to prevent duplicates.
	// Returns true if such a job exists, false otherwise.
	HasPendingOrRunningJob(ctx context.Context, templateID string) (bool, error)
	ListActiveAPIKeys(ctx context.Context) ([]ApiKey, error)
	ListAllActiveRecurringTemplates(ctx context.Context) ([]RecurringTaskTemplate, error)
	ListAllRecurringTemplatesByList(ctx context.Context, listID string) ([]RecurringTaskTemplate, error)
	ListPendingGenerationJobs(ctx context.Context, arg ListPendingGenerationJobsParams) ([]RecurringGenerationJob, error)
	ListRecurringTemplates(ctx context.Context, listID string) ([]RecurringTaskTemplate, error)
	// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
	// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
	// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
	//
	// Parameters (use empty arrays for NULL to skip filters):
	//   $1: list_id           - Filter by specific list (zero UUID to search all lists)
	//   $2: statuses          - Array of statuses to include (empty array to skip, OR logic)
	//   $3: priorities        - Array of priorities to include (empty array to skip, OR logic)
	//   $4: tags              - Array of tags to match (empty array to skip, item must have ALL tags)
	//   $5: due_before        - Filter tasks due before timestamp (zero time to skip)
	//   $6: due_after         - Filter tasks due after timestamp (zero time to skip)
	//   $7: updated_at        - Filter by last update time (zero time to skip)
	//   $8: created_at        - Filter by creation time (zero time to skip)
	//   $9: order_by          - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
	//                           Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
	//                           For bare field names, defaults are: due_time=asc, priority=asc,
	//                           created_at=desc, updated_at=desc
	//   $10: limit            - Page size (max items to return)
	//   $11: offset           - Pagination offset (skip N items)
	//   $12: excluded_statuses - Array of statuses to exclude (empty array to skip filter)
	//                           Used to exclude archived/cancelled by default when $2 is empty
	//
	// Returns: All todo_items columns plus total_count (total matching rows across all pages)
	// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
	// enabling accurate pagination UI without a separate count query.
	//
	// SQL Injection Protection:
	// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
	// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
	// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
	// flows through without validation, it's compared as a string literal in CASE expressions,
	// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
	// See tests/integration/sql_injection_resistance_test.go for proof.
	//
	// Input validation at the service layer improves UX (clear error messages) but does NOT
	// provide security - parameterized queries are the security boundary.
	//
	// Access pattern examples:
	//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
	//   - "Active work": statuses=[todo, in_progress], default sort
	//   - "High priority items": priorities=[high, urgent], order by due_time_asc
	//   - "Tasks tagged 'urgent' and 'work'": tags=[urgent, work] (item must have both)
	ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error)
	// Legacy query: Returns all lists without items (use ListTodoListsWithCounts for list views).
	ListTodoLists(ctx context.Context) ([]TodoList, error)
	// Optimized for LIST VIEW access pattern: Returns list metadata with item counts.
	// Performance: O(lists + items) with single aggregation query vs O(lists * items) loading all items.
	// Use case: Dashboard/overview pages showing list summaries without loading full item details.
	//
	// Returns:
	//   - total_items: Total count of all items in the list
	//   - undone_items: Count of items matching provided statuses (domain defines "undone")
	//
	// This query uses LEFT JOIN to ensure lists with zero items still appear with count=0.
	// The FILTER clause efficiently counts only matching items in a single pass.
	ListTodoListsWithCounts(ctx context.Context, undoneStatuses []string) ([]ListTodoListsWithCountsRow, error)
	// Updates last_used_at only if the new timestamp is later than the current value.
	// Returns 0 rows affected if: (1) key doesn't exist, OR (2) timestamp not later.
	// Repository uses CheckAPIKeyExists to distinguish these cases.
	UpdateAPIKeyLastUsed(ctx context.Context, arg UpdateAPIKeyLastUsedParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	//
	// retry_count is preserved automatically (not in SET clause)
	// Critical for worker: Detects if job was deleted/claimed by another worker between operations
	UpdateGenerationJobStatus(ctx context.Context, arg UpdateGenerationJobStatusParams) (int64, error)
	// FIELD MASK PATTERN: Selective field updates with CASE expressions
	// Only updates fields where set_<field> = true (field mask support)
	// CONCURRENCY: Optional version check for optimistic locking
	// Returns NULL if:
	//   - Template doesn't exist
	//   - Version mismatch (when expected_version provided)
	UpdateRecurringTemplate(ctx context.Context, arg UpdateRecurringTemplateParams) (RecurringTaskTemplate, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Critical for worker: Detects if template was deleted between job claim and generation
	UpdateRecurringTemplateGenerationWindow(ctx context.Context, arg UpdateRecurringTemplateGenerationWindowParams) (int64, error)
	// DATA ACCESS PATTERN: Partial update with explicit flags
	// Supports field masks by passing boolean flags for fields to update
	// Returns updated row, or pgx.ErrNoRows if:
	//   - Item doesn't exist
	//   - Item belongs to different list (security: prevents cross-list updates)
	//   - Version mismatch (concurrency: prevents lost updates)
	// SECURITY: Validates item belongs to the specified list
	// CONCURRENCY: Optional version check for optimistic locking
	// TYPE SAFETY: All fields managed by sqlc - schema changes caught at compile time
	UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (TodoItem, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient status updates without separate existence check
	UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error)
	// ATOMIC UPDATE WITH COUNTS: Uses CTE to update and return counts in single statement.
	// Prevents race conditions where counts could change between UPDATE and SELECT.
	//
	// FIELD MASK PATTERN: Selective field updates with CASE expressions
	// Only updates fields where set_<field> = true (field mask support)
	// CONCURRENCY: Optional version check for optimistic locking
	// Returns no rows if:
	//   - List doesn't exist
	//   - Version mismatch (when expected_version provided)
	UpdateTodoList(ctx context.Context, arg UpdateTodoListParams) (UpdateTodoListRow, error)
}

var _ Querier = (*Queries)(nil)
