// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	// Counts total matching items for pagination (used when main query returns empty page).
	// Uses same WHERE clause as ListTasksWithFilters for consistency.
	CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error)
	// Count total matching lists for pagination (same filters as FindTodoListsWithFilters).
	CountTodoListsWithFilters(ctx context.Context, arg CountTodoListsWithFiltersParams) (int32, error)
	CreateAPIKey(ctx context.Context, arg CreateAPIKeyParams) error
	// Creates a new generation job. For immediate scheduling, pass NULL for scheduled_for
	// to use the database's transaction timestamp (DEFAULT now()). This prevents clock skew
	// between the application and database from making jobs temporarily unclaimable.
	// For future scheduling, pass an explicit timestamp to override the default.
	CreateGenerationJob(ctx context.Context, arg CreateGenerationJobParams) error
	CreateRecurringTemplate(ctx context.Context, arg CreateRecurringTemplateParams) error
	CreateStatusHistoryEntry(ctx context.Context, arg CreateStatusHistoryEntryParams) error
	CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error
	CreateTodoList(ctx context.Context, arg CreateTodoListParams) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Revokes API key with existence check in single operation
	DeactivateAPIKey(ctx context.Context, id pgtype.UUID) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Soft delete with existence detection in single operation
	DeactivateRecurringTemplate(ctx context.Context, arg DeactivateRecurringTemplateParams) (int64, error)
	DeleteCompletedGenerationJobs(ctx context.Context, completedAt pgtype.Timestamptz) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Hard delete with built-in existence verification
	DeleteRecurringTemplate(ctx context.Context, id pgtype.UUID) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Single-query delete with existence detection built-in
	DeleteTodoItem(ctx context.Context, id pgtype.UUID) (int64, error)
	DeleteTodoItemsByListId(ctx context.Context, listID pgtype.UUID) error
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient detection of non-existent records without separate SELECT query
	DeleteTodoList(ctx context.Context, id pgtype.UUID) (int64, error)
	// Advanced list query with filtering, sorting, and pagination.
	// Supports AIP-160-style filtering and AIP-132-style sorting.
	//
	// Parameters use nullable types for optional filters:
	//   - title_contains: Filters by title substring (case-insensitive)
	//   - create_time_after: Filters lists created after this time
	//   - create_time_before: Filters lists created before this time
	//   - order_by: Column to sort by ("create_time" or "title")
	//   - order_dir: Sort direction ("asc" or "desc")
	//   - page_limit: Maximum number of results to return
	//   - page_offset: Number of results to skip
	FindTodoListsWithFilters(ctx context.Context, arg FindTodoListsWithFiltersParams) ([]FindTodoListsWithFiltersRow, error)
	GetAPIKeyByShortToken(ctx context.Context, shortToken string) (ApiKey, error)
	GetAllTodoItems(ctx context.Context) ([]TodoItem, error)
	GetGenerationJob(ctx context.Context, id pgtype.UUID) (RecurringGenerationJob, error)
	GetRecurringTemplate(ctx context.Context, id pgtype.UUID) (RecurringTaskTemplate, error)
	GetTaskStatusHistory(ctx context.Context, taskID pgtype.UUID) ([]TaskStatusHistory, error)
	GetTaskStatusHistoryByDateRange(ctx context.Context, arg GetTaskStatusHistoryByDateRangeParams) ([]TaskStatusHistory, error)
	GetTodoItem(ctx context.Context, id pgtype.UUID) (TodoItem, error)
	GetTodoItemsByListId(ctx context.Context, listID pgtype.UUID) ([]TodoItem, error)
	GetTodoList(ctx context.Context, id pgtype.UUID) (TodoList, error)
	// Returns a single list by ID with item counts (for detail view).
	// undone_statuses parameter: domain layer defines which statuses count as "undone".
	GetTodoListWithCounts(ctx context.Context, arg GetTodoListWithCountsParams) (GetTodoListWithCountsRow, error)
	// Checks if a template already has a pending or running job to prevent duplicates.
	// Returns true if such a job exists, false otherwise.
	HasPendingOrRunningJob(ctx context.Context, templateID pgtype.UUID) (bool, error)
	ListActiveAPIKeys(ctx context.Context) ([]ApiKey, error)
	ListAllActiveRecurringTemplates(ctx context.Context) ([]RecurringTaskTemplate, error)
	ListAllRecurringTemplatesByList(ctx context.Context, listID pgtype.UUID) ([]RecurringTaskTemplate, error)
	ListPendingGenerationJobs(ctx context.Context, arg ListPendingGenerationJobsParams) ([]RecurringGenerationJob, error)
	ListRecurringTemplates(ctx context.Context, listID pgtype.UUID) ([]RecurringTaskTemplate, error)
	// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
	// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
	// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
	//
	// Parameters (use zero values for NULL to skip filters):
	//   $1: list_id     - Filter by specific list (zero UUID to search all lists)
	//   $2: status      - Filter by status (empty string to skip)
	//   $3: priority    - Filter by priority (empty string to skip)
	//   $4: tag         - Filter by tag (JSONB array contains, empty string to skip)
	//   $5: due_before  - Filter tasks due before timestamp (zero time to skip)
	//   $6: due_after   - Filter tasks due after timestamp (zero time to skip)
	//   $7: updated_at  - Filter by last update time (zero time to skip)
	//   $8: created_at  - Filter by creation time (zero time to skip)
	//   $9: order_by    - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
	//                     Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
	//                     For bare field names, defaults are: due_time=asc, priority=asc,
	//                     created_at=desc, updated_at=desc
	//   $10: limit      - Page size (max items to return)
	//   $11: offset     - Pagination offset (skip N items)
	//
	// Returns: All todo_items columns plus total_count (total matching rows across all pages)
	// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
	// enabling accurate pagination UI without a separate count query.
	//
	// SQL Injection Protection:
	// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
	// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
	// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
	// flows through without validation, it's compared as a string literal in CASE expressions,
	// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
	// See tests/integration/sql_injection_resistance_test.go for proof.
	//
	// Input validation at the service layer improves UX (clear error messages) but does NOT
	// provide security - parameterized queries are the security boundary.
	//
	// Access pattern example:
	//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
	//   - "Tasks in List X": filter by list_id, default sort
	//   - "High priority items": filter by priority=HIGH, order by due_time_asc
	//   - "Tasks tagged 'urgent'": filter by tag=urgent (uses GIN index)
	ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error)
	// Legacy query: Returns all lists without items (use ListTodoListsWithCounts for list views).
	ListTodoLists(ctx context.Context) ([]TodoList, error)
	// Optimized for LIST VIEW access pattern: Returns list metadata with item counts.
	// Performance: O(lists + items) with single aggregation query vs O(lists * items) loading all items.
	// Use case: Dashboard/overview pages showing list summaries without loading full item details.
	//
	// Returns:
	//   - total_items: Total count of all items in the list
	//   - undone_items: Count of items matching provided statuses (domain defines "undone")
	//
	// This query uses LEFT JOIN to ensure lists with zero items still appear with count=0.
	// The FILTER clause efficiently counts only matching items in a single pass.
	ListTodoListsWithCounts(ctx context.Context, undoneStatuses []string) ([]ListTodoListsWithCountsRow, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Updates last access timestamp with existence detection in single query
	UpdateAPIKeyLastUsed(ctx context.Context, arg UpdateAPIKeyLastUsedParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	//
	// retry_count is preserved automatically (not in SET clause)
	// Critical for worker: Detects if job was deleted/claimed by another worker between operations
	UpdateGenerationJobStatus(ctx context.Context, arg UpdateGenerationJobStatusParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) where int64 is the number of rows affected
	//
	// Why this pattern:
	//   - Single database round-trip (vs two-query SELECT+UPDATE pattern)
	//   - No race condition: record cannot be deleted between check and update
	//   - Efficient: PostgreSQL returns affected count with no additional cost
	//   - Repository layer checks: rowsAffected == 0 → domain.ErrNotFound
	//
	// Anti-pattern to avoid:
	//   SELECT to check existence, then UPDATE if found
	//   - Two round-trips to database
	//   - Race condition window between queries
	//   - Doubled network latency
	UpdateRecurringTemplate(ctx context.Context, arg UpdateRecurringTemplateParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Critical for worker: Detects if template was deleted between job claim and generation
	UpdateRecurringTemplateGenerationWindow(ctx context.Context, arg UpdateRecurringTemplateGenerationWindowParams) (int64, error)
	// DATA ACCESS PATTERN: Optimistic locking with version check
	// :execrows returns (int64, error) - Repository checks rowsAffected:
	//   0 → Either item doesn't exist, belongs to different list, OR version mismatch (concurrent update)
	//   1 → Success, version incremented
	// SECURITY: Validates item belongs to the specified list to prevent cross-list updates
	// CONCURRENCY: Version check prevents lost updates in race conditions
	UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Efficient status updates without separate existence check
	UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error)
	// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
	// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
	// Avoids two-query anti-pattern (SELECT then UPDATE) with race condition and doubled latency
	// NOTE: create_time is immutable after creation - only title can be updated
	UpdateTodoList(ctx context.Context, arg UpdateTodoListParams) (int64, error)
}

var _ Querier = (*Queries)(nil)
