// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: todo_items.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTasksWithFilters = `-- name: CountTasksWithFilters :one
SELECT COUNT(*) FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    ($2::text = '' OR status = $2) AND
    ($3::text = '' OR priority = $3) AND
    ($4::text = '' OR tags ? $4::text) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
`

type CountTasksWithFiltersParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 string             `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 string             `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Column7 pgtype.Timestamptz `json:"column_7"`
	Column8 pgtype.Timestamptz `json:"column_8"`
}

// Counts total matching items for pagination (used when main query returns empty page).
// Uses same WHERE clause as ListTasksWithFilters for consistency.
func (q *Queries) CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTodoItem = `-- name: CreateTodoItem :exec
INSERT INTO todo_items (
    id, list_id, title, status, priority,
    estimated_duration, actual_duration,
    create_time, updated_at, due_time, tags,
    recurring_template_id, instance_date, timezone,
    version
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14,
    1
)
`

type CreateTodoItemParams struct {
	ID                  pgtype.UUID        `json:"id"`
	ListID              pgtype.UUID        `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            *string            `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreateTime          pgtype.Timestamptz `json:"create_time"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DueTime             pgtype.Timestamptz `json:"due_time"`
	Tags                []byte             `json:"tags"`
	RecurringTemplateID pgtype.UUID        `json:"recurring_template_id"`
	InstanceDate        pgtype.Date        `json:"instance_date"`
	Timezone            *string            `json:"timezone"`
}

func (q *Queries) CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error {
	_, err := q.db.Exec(ctx, createTodoItem,
		arg.ID,
		arg.ListID,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.CreateTime,
		arg.UpdatedAt,
		arg.DueTime,
		arg.Tags,
		arg.RecurringTemplateID,
		arg.InstanceDate,
		arg.Timezone,
	)
	return err
}

const deleteTodoItem = `-- name: DeleteTodoItem :execrows
DELETE FROM todo_items
WHERE id = $1
`

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Single-query delete with existence detection built-in
func (q *Queries) DeleteTodoItem(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTodoItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTodoItemsByListId = `-- name: DeleteTodoItemsByListId :exec
DELETE FROM todo_items
WHERE list_id = $1
`

func (q *Queries) DeleteTodoItemsByListId(ctx context.Context, listID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTodoItemsByListId, listID)
	return err
}

const getAllTodoItems = `-- name: GetAllTodoItems :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
ORDER BY list_id, create_time ASC
`

func (q *Queries) GetAllTodoItems(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getAllTodoItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodoItem = `-- name: GetTodoItem :one
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
WHERE id = $1
`

func (q *Queries) GetTodoItem(ctx context.Context, id pgtype.UUID) (TodoItem, error) {
	row := q.db.QueryRow(ctx, getTodoItem, id)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreateTime,
		&i.UpdatedAt,
		&i.DueTime,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.InstanceDate,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const getTodoItemsByListId = `-- name: GetTodoItemsByListId :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
WHERE list_id = $1
ORDER BY create_time ASC
`

func (q *Queries) GetTodoItemsByListId(ctx context.Context, listID pgtype.UUID) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getTodoItemsByListId, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksWithFilters = `-- name: ListTasksWithFilters :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version, COUNT(*) OVER() AS total_count FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    ($2::text = '' OR status = $2) AND
    ($3::text = '' OR priority = $3) AND
    ($4::text = '' OR tags ? $4::text) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
ORDER BY
    -- due_time: default ASC
    CASE WHEN $9::text IN ('due_time', 'due_time_asc') THEN due_time END ASC NULLS LAST,
    CASE WHEN $9::text = 'due_time_desc' THEN due_time END DESC NULLS LAST,
    -- priority: default ASC (semantic order: low=1 < medium=2 < high=3 < urgent=4)
    -- Uses numeric weights instead of lexical ordering to match proto enum semantics
    CASE WHEN $9::text IN ('priority', 'priority_asc') THEN
        CASE priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END ASC NULLS LAST,
    CASE WHEN $9::text = 'priority_desc' THEN
        CASE priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END DESC NULLS LAST,
    -- created_at: default DESC
    CASE WHEN $9::text = 'created_at_asc' THEN create_time END ASC,
    CASE WHEN $9::text IN ('created_at', 'created_at_desc') THEN create_time END DESC,
    -- updated_at: default DESC
    CASE WHEN $9::text = 'updated_at_asc' THEN updated_at END ASC,
    CASE WHEN $9::text IN ('updated_at', 'updated_at_desc') THEN updated_at END DESC,
    -- Fallback: created_at DESC (when no valid order_by specified)
    create_time DESC
LIMIT $10
OFFSET $11
`

type ListTasksWithFiltersParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 string             `json:"column_2"`
	Column3 string             `json:"column_3"`
	Column4 string             `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Column7 pgtype.Timestamptz `json:"column_7"`
	Column8 pgtype.Timestamptz `json:"column_8"`
	Column9 string             `json:"column_9"`
	Limit   int32              `json:"limit"`
	Offset  int32              `json:"offset"`
}

type ListTasksWithFiltersRow struct {
	ID                  pgtype.UUID        `json:"id"`
	ListID              pgtype.UUID        `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            *string            `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreateTime          pgtype.Timestamptz `json:"create_time"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DueTime             pgtype.Timestamptz `json:"due_time"`
	Tags                []byte             `json:"tags"`
	RecurringTemplateID pgtype.UUID        `json:"recurring_template_id"`
	InstanceDate        pgtype.Date        `json:"instance_date"`
	Timezone            *string            `json:"timezone"`
	Version             int32              `json:"version"`
	TotalCount          int64              `json:"total_count"`
}

// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
//
// Parameters (use zero values for NULL to skip filters):
//
//	$1: list_id     - Filter by specific list (zero UUID to search all lists)
//	$2: status      - Filter by status (empty string to skip)
//	$3: priority    - Filter by priority (empty string to skip)
//	$4: tag         - Filter by tag (JSONB array contains, empty string to skip)
//	$5: due_before  - Filter tasks due before timestamp (zero time to skip)
//	$6: due_after   - Filter tasks due after timestamp (zero time to skip)
//	$7: updated_at  - Filter by last update time (zero time to skip)
//	$8: created_at  - Filter by creation time (zero time to skip)
//	$9: order_by    - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
//	                  Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
//	                  For bare field names, defaults are: due_time=asc, priority=asc,
//	                  created_at=desc, updated_at=desc
//	$10: limit      - Page size (max items to return)
//	$11: offset     - Pagination offset (skip N items)
//
// Returns: All todo_items columns plus total_count (total matching rows across all pages)
// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
// enabling accurate pagination UI without a separate count query.
//
// SQL Injection Protection:
// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
// flows through without validation, it's compared as a string literal in CASE expressions,
// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
// See tests/integration/sql_injection_resistance_test.go for proof.
//
// Input validation at the service layer improves UX (clear error messages) but does NOT
// provide security - parameterized queries are the security boundary.
//
// Access pattern example:
//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
//   - "Tasks in List X": filter by list_id, default sort
//   - "High priority items": filter by priority=HIGH, order by due_time_asc
//   - "Tasks tagged 'urgent'": filter by tag=urgent (uses GIN index)
func (q *Queries) ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error) {
	rows, err := q.db.Query(ctx, listTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksWithFiltersRow{}
	for rows.Next() {
		var i ListTasksWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTodoItem = `-- name: UpdateTodoItem :execrows
UPDATE todo_items
SET title = $1,
    status = $2,
    priority = $3,
    estimated_duration = $4,
    actual_duration = $5,
    updated_at = $6,
    due_time = $7,
    tags = $8,
    timezone = $9,
    version = version + 1
WHERE id = $10
  AND list_id = $11
  AND version = $12
`

type UpdateTodoItemParams struct {
	Title             string             `json:"title"`
	Status            string             `json:"status"`
	Priority          *string            `json:"priority"`
	EstimatedDuration pgtype.Interval    `json:"estimated_duration"`
	ActualDuration    pgtype.Interval    `json:"actual_duration"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
	DueTime           pgtype.Timestamptz `json:"due_time"`
	Tags              []byte             `json:"tags"`
	Timezone          *string            `json:"timezone"`
	ID                pgtype.UUID        `json:"id"`
	ListID            pgtype.UUID        `json:"list_id"`
	Version           int32              `json:"version"`
}

// DATA ACCESS PATTERN: Optimistic locking with version check
// :execrows returns (int64, error) - Repository checks rowsAffected:
//
//	0 → Either item doesn't exist, belongs to different list, OR version mismatch (concurrent update)
//	1 → Success, version incremented
//
// SECURITY: Validates item belongs to the specified list to prevent cross-list updates
// CONCURRENCY: Version check prevents lost updates in race conditions
func (q *Queries) UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTodoItem,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.UpdatedAt,
		arg.DueTime,
		arg.Tags,
		arg.Timezone,
		arg.ID,
		arg.ListID,
		arg.Version,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const updateTodoItemStatus = `-- name: UpdateTodoItemStatus :execrows
UPDATE todo_items
SET status = $1, updated_at = $2
WHERE id = $3
`

type UpdateTodoItemStatusParams struct {
	Status    string             `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	ID        pgtype.UUID        `json:"id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Efficient status updates without separate existence check
func (q *Queries) UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTodoItemStatus, arg.Status, arg.UpdatedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
