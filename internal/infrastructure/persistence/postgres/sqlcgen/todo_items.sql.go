// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: todo_items.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/sqlc-dev/pqtype"
)

const countTasksWithFilters = `-- name: CountTasksWithFilters :one
SELECT COUNT(*) FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    ($2::text = '' OR status = $2) AND
    ($3::text = '' OR priority = $3) AND
    ($4::text = '' OR tags ? $4::text) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
`

type CountTasksWithFiltersParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Column6 time.Time `json:"column_6"`
	Column7 time.Time `json:"column_7"`
	Column8 time.Time `json:"column_8"`
}

// Counts total matching items for pagination (used when main query returns empty page).
// Uses same WHERE clause as ListTasksWithFilters for consistency.
func (q *Queries) CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTodoItem = `-- name: CreateTodoItem :exec
INSERT INTO todo_items (
    id, list_id, title, status, priority,
    estimated_duration, actual_duration,
    create_time, updated_at, due_time, tags,
    recurring_template_id, instance_date, timezone
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14
)
`

type CreateTodoItemParams struct {
	ID                  uuid.UUID             `json:"id"`
	ListID              uuid.UUID             `json:"list_id"`
	Title               string                `json:"title"`
	Status              string                `json:"status"`
	Priority            sql.NullString        `json:"priority"`
	EstimatedDuration   pgtype.Interval       `json:"estimated_duration"`
	ActualDuration      pgtype.Interval       `json:"actual_duration"`
	CreateTime          time.Time             `json:"create_time"`
	UpdatedAt           time.Time             `json:"updated_at"`
	DueTime             sql.NullTime          `json:"due_time"`
	Tags                pqtype.NullRawMessage `json:"tags"`
	RecurringTemplateID uuid.NullUUID         `json:"recurring_template_id"`
	InstanceDate        sql.NullTime          `json:"instance_date"`
	Timezone            sql.NullString        `json:"timezone"`
}

func (q *Queries) CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error {
	_, err := q.db.ExecContext(ctx, createTodoItem,
		arg.ID,
		arg.ListID,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.CreateTime,
		arg.UpdatedAt,
		arg.DueTime,
		arg.Tags,
		arg.RecurringTemplateID,
		arg.InstanceDate,
		arg.Timezone,
	)
	return err
}

const deleteTodoItem = `-- name: DeleteTodoItem :execrows
DELETE FROM todo_items
WHERE id = $1
`

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Single-query delete with existence detection built-in
func (q *Queries) DeleteTodoItem(ctx context.Context, id uuid.UUID) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteTodoItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTodoItemsByListId = `-- name: DeleteTodoItemsByListId :exec
DELETE FROM todo_items
WHERE list_id = $1
`

func (q *Queries) DeleteTodoItemsByListId(ctx context.Context, listID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteTodoItemsByListId, listID)
	return err
}

const getAllTodoItems = `-- name: GetAllTodoItems :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone FROM todo_items
ORDER BY list_id, create_time ASC
`

func (q *Queries) GetAllTodoItems(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, getAllTodoItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodoItem = `-- name: GetTodoItem :one
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone FROM todo_items
WHERE id = $1
`

func (q *Queries) GetTodoItem(ctx context.Context, id uuid.UUID) (TodoItem, error) {
	row := q.db.QueryRowContext(ctx, getTodoItem, id)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreateTime,
		&i.UpdatedAt,
		&i.DueTime,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.InstanceDate,
		&i.Timezone,
	)
	return i, err
}

const getTodoItemsByListId = `-- name: GetTodoItemsByListId :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone FROM todo_items
WHERE list_id = $1
ORDER BY create_time ASC
`

func (q *Queries) GetTodoItemsByListId(ctx context.Context, listID uuid.UUID) ([]TodoItem, error) {
	rows, err := q.db.QueryContext(ctx, getTodoItemsByListId, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksWithFilters = `-- name: ListTasksWithFilters :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, COUNT(*) OVER() AS total_count FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    ($2::text = '' OR status = $2) AND
    ($3::text = '' OR priority = $3) AND
    ($4::text = '' OR tags ? $4::text) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
ORDER BY
    -- due_time: default ASC
    CASE WHEN $9::text IN ('due_time', 'due_time_asc') THEN due_time END ASC NULLS LAST,
    CASE WHEN $9::text = 'due_time_desc' THEN due_time END DESC NULLS LAST,
    -- priority: default ASC (semantic order: LOW=1 < MEDIUM=2 < HIGH=3 < URGENT=4)
    -- Uses numeric weights instead of lexical ordering to match proto enum semantics
    CASE WHEN $9::text IN ('priority', 'priority_asc') THEN
        CASE priority
            WHEN 'LOW' THEN 1
            WHEN 'MEDIUM' THEN 2
            WHEN 'HIGH' THEN 3
            WHEN 'URGENT' THEN 4
        END
    END ASC NULLS LAST,
    CASE WHEN $9::text = 'priority_desc' THEN
        CASE priority
            WHEN 'LOW' THEN 1
            WHEN 'MEDIUM' THEN 2
            WHEN 'HIGH' THEN 3
            WHEN 'URGENT' THEN 4
        END
    END DESC NULLS LAST,
    -- created_at: default DESC
    CASE WHEN $9::text = 'created_at_asc' THEN create_time END ASC,
    CASE WHEN $9::text IN ('created_at', 'created_at_desc') THEN create_time END DESC,
    -- updated_at: default DESC
    CASE WHEN $9::text = 'updated_at_asc' THEN updated_at END ASC,
    CASE WHEN $9::text IN ('updated_at', 'updated_at_desc') THEN updated_at END DESC,
    -- Fallback: created_at DESC (when no valid order_by specified)
    create_time DESC
LIMIT $10
OFFSET $11
`

type ListTasksWithFiltersParams struct {
	Column1 uuid.UUID `json:"column_1"`
	Column2 string    `json:"column_2"`
	Column3 string    `json:"column_3"`
	Column4 string    `json:"column_4"`
	Column5 time.Time `json:"column_5"`
	Column6 time.Time `json:"column_6"`
	Column7 time.Time `json:"column_7"`
	Column8 time.Time `json:"column_8"`
	Column9 string    `json:"column_9"`
	Limit   int32     `json:"limit"`
	Offset  int32     `json:"offset"`
}

type ListTasksWithFiltersRow struct {
	ID                  uuid.UUID             `json:"id"`
	ListID              uuid.UUID             `json:"list_id"`
	Title               string                `json:"title"`
	Status              string                `json:"status"`
	Priority            sql.NullString        `json:"priority"`
	EstimatedDuration   pgtype.Interval       `json:"estimated_duration"`
	ActualDuration      pgtype.Interval       `json:"actual_duration"`
	CreateTime          time.Time             `json:"create_time"`
	UpdatedAt           time.Time             `json:"updated_at"`
	DueTime             sql.NullTime          `json:"due_time"`
	Tags                pqtype.NullRawMessage `json:"tags"`
	RecurringTemplateID uuid.NullUUID         `json:"recurring_template_id"`
	InstanceDate        sql.NullTime          `json:"instance_date"`
	Timezone            sql.NullString        `json:"timezone"`
	TotalCount          int64                 `json:"total_count"`
}

// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
//
// Parameters (use zero values for NULL to skip filters):
//
//	$1: list_id     - Filter by specific list (zero UUID to search all lists)
//	$2: status      - Filter by status (empty string to skip)
//	$3: priority    - Filter by priority (empty string to skip)
//	$4: tag         - Filter by tag (JSONB array contains, empty string to skip)
//	$5: due_before  - Filter tasks due before timestamp (zero time to skip)
//	$6: due_after   - Filter tasks due after timestamp (zero time to skip)
//	$7: updated_at  - Filter by last update time (zero time to skip)
//	$8: created_at  - Filter by creation time (zero time to skip)
//	$9: order_by    - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
//	                  Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
//	                  For bare field names, defaults are: due_time=asc, priority=asc,
//	                  created_at=desc, updated_at=desc
//	$10: limit      - Page size (max items to return)
//	$11: offset     - Pagination offset (skip N items)
//
// Returns: All todo_items columns plus total_count (total matching rows across all pages)
// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
// enabling accurate pagination UI without a separate count query.
//
// SQL Injection Protection:
// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
// flows through without validation, it's compared as a string literal in CASE expressions,
// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
// See tests/integration/sql_injection_resistance_test.go for proof.
//
// Input validation at the service layer improves UX (clear error messages) but does NOT
// provide security - parameterized queries are the security boundary.
//
// Access pattern example:
//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
//   - "Tasks in List X": filter by list_id, default sort
//   - "High priority items": filter by priority=HIGH, order by due_time_asc
//   - "Tasks tagged 'urgent'": filter by tag=urgent (uses GIN index)
func (q *Queries) ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksWithFiltersRow{}
	for rows.Next() {
		var i ListTasksWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTodoItem = `-- name: UpdateTodoItem :execrows
UPDATE todo_items
SET title = $1,
    status = $2,
    priority = $3,
    estimated_duration = $4,
    actual_duration = $5,
    updated_at = $6,
    due_time = $7,
    tags = $8,
    timezone = $9
WHERE id = $10 AND list_id = $11
`

type UpdateTodoItemParams struct {
	Title             string                `json:"title"`
	Status            string                `json:"status"`
	Priority          sql.NullString        `json:"priority"`
	EstimatedDuration pgtype.Interval       `json:"estimated_duration"`
	ActualDuration    pgtype.Interval       `json:"actual_duration"`
	UpdatedAt         time.Time             `json:"updated_at"`
	DueTime           sql.NullTime          `json:"due_time"`
	Tags              pqtype.NullRawMessage `json:"tags"`
	Timezone          sql.NullString        `json:"timezone"`
	ID                uuid.UUID             `json:"id"`
	ListID            uuid.UUID             `json:"list_id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Single database round-trip prevents race conditions and reduces latency
// SECURITY: Validates item belongs to the specified list to prevent cross-list updates
func (q *Queries) UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTodoItem,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.UpdatedAt,
		arg.DueTime,
		arg.Tags,
		arg.Timezone,
		arg.ID,
		arg.ListID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTodoItemStatus = `-- name: UpdateTodoItemStatus :execrows
UPDATE todo_items
SET status = $1, updated_at = $2
WHERE id = $3
`

type UpdateTodoItemStatusParams struct {
	Status    string    `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        uuid.UUID `json:"id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Efficient status updates without separate existence check
func (q *Queries) UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateTodoItemStatus, arg.Status, arg.UpdatedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
