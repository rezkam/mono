// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: todo_items.sql

package sqlcgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTasksWithFilters = `-- name: CountTasksWithFilters :one
SELECT COUNT(*) FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    (array_length($2::text[], 1) IS NULL OR status = ANY($2::text[])) AND
    (array_length($9::text[], 1) IS NULL OR status != ALL($9::text[])) AND
    (array_length($3::text[], 1) IS NULL OR priority = ANY($3::text[])) AND
    (array_length($4::text[], 1) IS NULL OR tags ?& $4::text[]) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
`

type CountTasksWithFiltersParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 []string           `json:"column_2"`
	Column3 []string           `json:"column_3"`
	Column4 []string           `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Column7 pgtype.Timestamptz `json:"column_7"`
	Column8 pgtype.Timestamptz `json:"column_8"`
	Column9 []string           `json:"column_9"`
}

// Counts total matching items for pagination (used when main query returns empty page).
// Uses same WHERE clause as ListTasksWithFilters for consistency.
// $2: statuses array (empty array skips filter, OR logic within array)
// $3: priorities array (empty array skips filter, OR logic within array)
// $4: tags array (empty array skips filter, item must have ALL specified tags)
// $9: excluded_statuses array (empty array skips filter, excludes matching statuses)
func (q *Queries) CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTodoItem = `-- name: CreateTodoItem :exec
INSERT INTO todo_items (
    id, list_id, title, status, priority,
    estimated_duration, actual_duration,
    create_time, updated_at, due_time, tags,
    recurring_template_id, instance_date, timezone,
    version
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14,
    1
)
`

type CreateTodoItemParams struct {
	ID                  pgtype.UUID        `json:"id"`
	ListID              pgtype.UUID        `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            *string            `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreateTime          pgtype.Timestamptz `json:"create_time"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DueTime             pgtype.Timestamptz `json:"due_time"`
	Tags                []byte             `json:"tags"`
	RecurringTemplateID pgtype.UUID        `json:"recurring_template_id"`
	InstanceDate        pgtype.Date        `json:"instance_date"`
	Timezone            *string            `json:"timezone"`
}

func (q *Queries) CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) error {
	_, err := q.db.Exec(ctx, createTodoItem,
		arg.ID,
		arg.ListID,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.CreateTime,
		arg.UpdatedAt,
		arg.DueTime,
		arg.Tags,
		arg.RecurringTemplateID,
		arg.InstanceDate,
		arg.Timezone,
	)
	return err
}

const deleteTodoItem = `-- name: DeleteTodoItem :execrows
DELETE FROM todo_items
WHERE id = $1
`

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Single-query delete with existence detection built-in
func (q *Queries) DeleteTodoItem(ctx context.Context, id pgtype.UUID) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTodoItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTodoItemsByListId = `-- name: DeleteTodoItemsByListId :exec
DELETE FROM todo_items
WHERE list_id = $1
`

func (q *Queries) DeleteTodoItemsByListId(ctx context.Context, listID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTodoItemsByListId, listID)
	return err
}

const getAllTodoItems = `-- name: GetAllTodoItems :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
ORDER BY list_id, create_time ASC
`

func (q *Queries) GetAllTodoItems(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getAllTodoItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodoItem = `-- name: GetTodoItem :one
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
WHERE id = $1
`

func (q *Queries) GetTodoItem(ctx context.Context, id pgtype.UUID) (TodoItem, error) {
	row := q.db.QueryRow(ctx, getTodoItem, id)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreateTime,
		&i.UpdatedAt,
		&i.DueTime,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.InstanceDate,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const getTodoItemsByListId = `-- name: GetTodoItemsByListId :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version FROM todo_items
WHERE list_id = $1
ORDER BY create_time ASC
`

func (q *Queries) GetTodoItemsByListId(ctx context.Context, listID pgtype.UUID) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getTodoItemsByListId, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasksWithFilters = `-- name: ListTasksWithFilters :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version, COUNT(*) OVER() AS total_count FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    (array_length($2::text[], 1) IS NULL OR status = ANY($2::text[])) AND
    (array_length($12::text[], 1) IS NULL OR status != ALL($12::text[])) AND
    (array_length($3::text[], 1) IS NULL OR priority = ANY($3::text[])) AND
    (array_length($4::text[], 1) IS NULL OR tags ?& $4::text[]) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_time <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_time >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR create_time >= $8)
ORDER BY
    -- due_time: default ASC
    CASE WHEN $9::text IN ('due_time', 'due_time_asc') THEN due_time END ASC NULLS LAST,
    CASE WHEN $9::text = 'due_time_desc' THEN due_time END DESC NULLS LAST,
    -- priority: default ASC (semantic order: low=1 < medium=2 < high=3 < urgent=4)
    -- Uses numeric weights instead of lexical ordering to match proto enum semantics
    CASE WHEN $9::text IN ('priority', 'priority_asc') THEN
        CASE priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END ASC NULLS LAST,
    CASE WHEN $9::text = 'priority_desc' THEN
        CASE priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END DESC NULLS LAST,
    -- created_at: default DESC
    CASE WHEN $9::text = 'created_at_asc' THEN create_time END ASC,
    CASE WHEN $9::text IN ('created_at', 'created_at_desc') THEN create_time END DESC,
    -- updated_at: default DESC
    CASE WHEN $9::text = 'updated_at_asc' THEN updated_at END ASC,
    CASE WHEN $9::text IN ('updated_at', 'updated_at_desc') THEN updated_at END DESC,
    -- Fallback: created_at DESC (when no valid order_by specified)
    create_time DESC
LIMIT $10
OFFSET $11
`

type ListTasksWithFiltersParams struct {
	Column1  pgtype.UUID        `json:"column_1"`
	Column2  []string           `json:"column_2"`
	Column3  []string           `json:"column_3"`
	Column4  []string           `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
	Column7  pgtype.Timestamptz `json:"column_7"`
	Column8  pgtype.Timestamptz `json:"column_8"`
	Column9  string             `json:"column_9"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
	Column12 []string           `json:"column_12"`
}

type ListTasksWithFiltersRow struct {
	ID                  pgtype.UUID        `json:"id"`
	ListID              pgtype.UUID        `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            *string            `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreateTime          pgtype.Timestamptz `json:"create_time"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	DueTime             pgtype.Timestamptz `json:"due_time"`
	Tags                []byte             `json:"tags"`
	RecurringTemplateID pgtype.UUID        `json:"recurring_template_id"`
	InstanceDate        pgtype.Date        `json:"instance_date"`
	Timezone            *string            `json:"timezone"`
	Version             int32              `json:"version"`
	TotalCount          int64              `json:"total_count"`
}

// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
//
// Parameters (use empty arrays for NULL to skip filters):
//
//	$1: list_id           - Filter by specific list (zero UUID to search all lists)
//	$2: statuses          - Array of statuses to include (empty array to skip, OR logic)
//	$3: priorities        - Array of priorities to include (empty array to skip, OR logic)
//	$4: tags              - Array of tags to match (empty array to skip, item must have ALL tags)
//	$5: due_before        - Filter tasks due before timestamp (zero time to skip)
//	$6: due_after         - Filter tasks due after timestamp (zero time to skip)
//	$7: updated_at        - Filter by last update time (zero time to skip)
//	$8: created_at        - Filter by creation time (zero time to skip)
//	$9: order_by          - Combined field+direction: 'due_time_asc', 'due_time_desc', etc.
//	                        Supports: due_time, priority, created_at, updated_at with _asc or _desc suffix
//	                        For bare field names, defaults are: due_time=asc, priority=asc,
//	                        created_at=desc, updated_at=desc
//	$10: limit            - Page size (max items to return)
//	$11: offset           - Pagination offset (skip N items)
//	$12: excluded_statuses - Array of statuses to exclude (empty array to skip filter)
//	                        Used to exclude archived/cancelled by default when $2 is empty
//
// Returns: All todo_items columns plus total_count (total matching rows across all pages)
// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
// enabling accurate pagination UI without a separate count query.
//
// SQL Injection Protection:
// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
// flows through without validation, it's compared as a string literal in CASE expressions,
// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
// See tests/integration/sql_injection_resistance_test.go for proof.
//
// Input validation at the service layer improves UX (clear error messages) but does NOT
// provide security - parameterized queries are the security boundary.
//
// Access pattern examples:
//   - "Show my overdue tasks": filter by due_before=now, order by due_time_asc
//   - "Active work": statuses=[todo, in_progress], default sort
//   - "High priority items": priorities=[high, urgent], order by due_time_asc
//   - "Tasks tagged 'urgent' and 'work'": tags=[urgent, work] (item must have both)
func (q *Queries) ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error) {
	rows, err := q.db.Query(ctx, listTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
		arg.Offset,
		arg.Column12,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksWithFiltersRow{}
	for rows.Next() {
		var i ListTasksWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreateTime,
			&i.UpdatedAt,
			&i.DueTime,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.InstanceDate,
			&i.Timezone,
			&i.Version,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTodoItem = `-- name: UpdateTodoItem :one
UPDATE todo_items
SET title = CASE WHEN $1::boolean THEN $2 ELSE title END,
    status = CASE WHEN $3::boolean THEN $4 ELSE status END,
    priority = CASE WHEN $5::boolean THEN $6 ELSE priority END,
    estimated_duration = CASE WHEN $7::boolean THEN $8 ELSE estimated_duration END,
    actual_duration = CASE WHEN $9::boolean THEN $10 ELSE actual_duration END,
    due_time = CASE WHEN $11::boolean THEN $12 ELSE due_time END,
    tags = CASE WHEN $13::boolean THEN $14 ELSE tags END,
    timezone = CASE WHEN $15::boolean THEN $16 ELSE timezone END,
    updated_at = NOW(),
    version = version + 1
WHERE id = $17
  AND list_id = $18
  AND ($19::integer IS NULL OR version = $19::integer)
RETURNING id, list_id, title, status, priority, estimated_duration, actual_duration, create_time, updated_at, due_time, tags, recurring_template_id, instance_date, timezone, version
`

type UpdateTodoItemParams struct {
	SetTitle             bool               `json:"set_title"`
	Title                *string            `json:"title"`
	SetStatus            bool               `json:"set_status"`
	Status               *string            `json:"status"`
	SetPriority          bool               `json:"set_priority"`
	Priority             *string            `json:"priority"`
	SetEstimatedDuration bool               `json:"set_estimated_duration"`
	EstimatedDuration    pgtype.Interval    `json:"estimated_duration"`
	SetActualDuration    bool               `json:"set_actual_duration"`
	ActualDuration       pgtype.Interval    `json:"actual_duration"`
	SetDueTime           bool               `json:"set_due_time"`
	DueTime              pgtype.Timestamptz `json:"due_time"`
	SetTags              bool               `json:"set_tags"`
	Tags                 []byte             `json:"tags"`
	SetTimezone          bool               `json:"set_timezone"`
	Timezone             *string            `json:"timezone"`
	ID                   pgtype.UUID        `json:"id"`
	ListID               pgtype.UUID        `json:"list_id"`
	ExpectedVersion      *int32             `json:"expected_version"`
}

// DATA ACCESS PATTERN: Partial update with explicit flags
// Supports field masks by passing boolean flags for fields to update
// Returns updated row, or pgx.ErrNoRows if:
//   - Item doesn't exist
//   - Item belongs to different list (security: prevents cross-list updates)
//   - Version mismatch (concurrency: prevents lost updates)
//
// SECURITY: Validates item belongs to the specified list
// CONCURRENCY: Optional version check for optimistic locking
// TYPE SAFETY: All fields managed by sqlc - schema changes caught at compile time
func (q *Queries) UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (TodoItem, error) {
	row := q.db.QueryRow(ctx, updateTodoItem,
		arg.SetTitle,
		arg.Title,
		arg.SetStatus,
		arg.Status,
		arg.SetPriority,
		arg.Priority,
		arg.SetEstimatedDuration,
		arg.EstimatedDuration,
		arg.SetActualDuration,
		arg.ActualDuration,
		arg.SetDueTime,
		arg.DueTime,
		arg.SetTags,
		arg.Tags,
		arg.SetTimezone,
		arg.Timezone,
		arg.ID,
		arg.ListID,
		arg.ExpectedVersion,
	)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreateTime,
		&i.UpdatedAt,
		&i.DueTime,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.InstanceDate,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const updateTodoItemStatus = `-- name: UpdateTodoItemStatus :execrows
UPDATE todo_items
SET status = $1, updated_at = $2
WHERE id = $3
`

type UpdateTodoItemStatusParams struct {
	Status    string             `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	ID        pgtype.UUID        `json:"id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Efficient status updates without separate existence check
func (q *Queries) UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTodoItemStatus, arg.Status, arg.UpdatedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
