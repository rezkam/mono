// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: todo_items.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BatchCreateTodoItemsParams struct {
	ID                  string             `json:"id"`
	ListID              string             `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            sql.Null[string]   `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	DueAt               pgtype.Timestamptz `json:"due_at"`
	Tags                []string           `json:"tags"`
	RecurringTemplateID uuid.NullUUID      `json:"recurring_template_id"`
	StartsAt            pgtype.Date        `json:"starts_at"`
	OccursAt            pgtype.Timestamptz `json:"occurs_at"`
	DueOffset           pgtype.Interval    `json:"due_offset"`
	Timezone            sql.Null[string]   `json:"timezone"`
	Version             int32              `json:"version"`
}

const countTasksWithFilters = `-- name: CountTasksWithFilters :one
SELECT COUNT(*) FROM todo_items
WHERE
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR list_id = $1) AND
    (array_length($2::text[], 1) IS NULL OR status = ANY($2::text[])) AND
    (array_length($9::text[], 1) IS NULL OR status != ALL($9::text[])) AND
    (array_length($3::text[], 1) IS NULL OR priority = ANY($3::text[])) AND
    (array_length($4::text[], 1) IS NULL OR tags @> $4::text[]) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR due_at <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR due_at >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR created_at >= $8)
`

type CountTasksWithFiltersParams struct {
	Column1 pgtype.UUID        `json:"column_1"`
	Column2 []string           `json:"column_2"`
	Column3 []string           `json:"column_3"`
	Column4 []string           `json:"column_4"`
	Column5 pgtype.Timestamptz `json:"column_5"`
	Column6 pgtype.Timestamptz `json:"column_6"`
	Column7 pgtype.Timestamptz `json:"column_7"`
	Column8 pgtype.Timestamptz `json:"column_8"`
	Column9 []string           `json:"column_9"`
}

// Counts total matching items for pagination (used when main query returns empty page).
// Uses same WHERE clause as ListTasksWithFilters for consistency.
// $2: statuses array (empty array skips filter, OR logic within array)
// $3: priorities array (empty array skips filter, OR logic within array)
// $4: tags array (empty array skips filter, item must have ALL specified tags)
// $9: excluded_statuses array (empty array skips filter, excludes matching statuses)
func (q *Queries) CountTasksWithFilters(ctx context.Context, arg CountTasksWithFiltersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTodoItem = `-- name: CreateTodoItem :one
INSERT INTO todo_items (
    id, list_id, title, status, priority,
    estimated_duration, actual_duration,
    created_at, updated_at, due_at, tags,
    recurring_template_id, starts_at, occurs_at, due_offset, timezone
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14, $15, $16
)
RETURNING id, list_id, title, status, priority, estimated_duration, actual_duration, created_at, updated_at, due_at, tags, recurring_template_id, starts_at, occurs_at, due_offset, timezone, version
`

type CreateTodoItemParams struct {
	ID                  string             `json:"id"`
	ListID              string             `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            sql.Null[string]   `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	DueAt               pgtype.Timestamptz `json:"due_at"`
	Tags                []string           `json:"tags"`
	RecurringTemplateID uuid.NullUUID      `json:"recurring_template_id"`
	StartsAt            pgtype.Date        `json:"starts_at"`
	OccursAt            pgtype.Timestamptz `json:"occurs_at"`
	DueOffset           pgtype.Interval    `json:"due_offset"`
	Timezone            sql.Null[string]   `json:"timezone"`
}

func (q *Queries) CreateTodoItem(ctx context.Context, arg CreateTodoItemParams) (TodoItem, error) {
	row := q.db.QueryRow(ctx, createTodoItem,
		arg.ID,
		arg.ListID,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DueAt,
		arg.Tags,
		arg.RecurringTemplateID,
		arg.StartsAt,
		arg.OccursAt,
		arg.DueOffset,
		arg.Timezone,
	)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DueAt,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.StartsAt,
		&i.OccursAt,
		&i.DueOffset,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const deleteFuturePendingItems = `-- name: DeleteFuturePendingItems :execrows
DELETE FROM todo_items
WHERE recurring_template_id = $1
  AND occurs_at >= $2
  AND status = 'todo'
`

type DeleteFuturePendingItemsParams struct {
	RecurringTemplateID uuid.NullUUID      `json:"recurring_template_id"`
	OccursAt            pgtype.Timestamptz `json:"occurs_at"`
}

// Delete future pending items for a template (used before regeneration)
func (q *Queries) DeleteFuturePendingItems(ctx context.Context, arg DeleteFuturePendingItemsParams) (int64, error) {
	result, err := q.db.Exec(ctx, deleteFuturePendingItems, arg.RecurringTemplateID, arg.OccursAt)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTodoItem = `-- name: DeleteTodoItem :execrows
DELETE FROM todo_items
WHERE id = $1
`

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Single-query delete with existence detection built-in
func (q *Queries) DeleteTodoItem(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteTodoItem, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteTodoItemsByListId = `-- name: DeleteTodoItemsByListId :exec
DELETE FROM todo_items
WHERE list_id = $1
`

func (q *Queries) DeleteTodoItemsByListId(ctx context.Context, listID string) error {
	_, err := q.db.Exec(ctx, deleteTodoItemsByListId, listID)
	return err
}

const getAllTodoItems = `-- name: GetAllTodoItems :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, created_at, updated_at, due_at, tags, recurring_template_id, starts_at, occurs_at, due_offset, timezone, version FROM todo_items
ORDER BY list_id, created_at ASC
`

func (q *Queries) GetAllTodoItems(ctx context.Context) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getAllTodoItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DueAt,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.StartsAt,
			&i.OccursAt,
			&i.DueOffset,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTodoItem = `-- name: GetTodoItem :one
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, created_at, updated_at, due_at, tags, recurring_template_id, starts_at, occurs_at, due_offset, timezone, version FROM todo_items
WHERE id = $1
`

func (q *Queries) GetTodoItem(ctx context.Context, id string) (TodoItem, error) {
	row := q.db.QueryRow(ctx, getTodoItem, id)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DueAt,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.StartsAt,
		&i.OccursAt,
		&i.DueOffset,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const getTodoItemsByListId = `-- name: GetTodoItemsByListId :many
SELECT id, list_id, title, status, priority, estimated_duration, actual_duration, created_at, updated_at, due_at, tags, recurring_template_id, starts_at, occurs_at, due_offset, timezone, version FROM todo_items
WHERE list_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetTodoItemsByListId(ctx context.Context, listID string) ([]TodoItem, error) {
	rows, err := q.db.Query(ctx, getTodoItemsByListId, listID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TodoItem{}
	for rows.Next() {
		var i TodoItem
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DueAt,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.StartsAt,
			&i.OccursAt,
			&i.DueOffset,
			&i.Timezone,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertItemIgnoreConflict = `-- name: InsertItemIgnoreConflict :exec
INSERT INTO todo_items (
    id, list_id, title, status, priority,
    estimated_duration, actual_duration,
    created_at, updated_at, due_at, tags,
    recurring_template_id, starts_at, occurs_at, due_offset, timezone,
    version
) VALUES (
    $1, $2, $3, $4, $5,
    $6, $7,
    $8, $9, $10, $11,
    $12, $13, $14, $15, $16,
    $17
)
ON CONFLICT (recurring_template_id, occurs_at) WHERE recurring_template_id IS NOT NULL
DO NOTHING
`

type InsertItemIgnoreConflictParams struct {
	ID                  string             `json:"id"`
	ListID              string             `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            sql.Null[string]   `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	DueAt               pgtype.Timestamptz `json:"due_at"`
	Tags                []string           `json:"tags"`
	RecurringTemplateID uuid.NullUUID      `json:"recurring_template_id"`
	StartsAt            pgtype.Date        `json:"starts_at"`
	OccursAt            pgtype.Timestamptz `json:"occurs_at"`
	DueOffset           pgtype.Interval    `json:"due_offset"`
	Timezone            sql.Null[string]   `json:"timezone"`
	Version             int32              `json:"version"`
}

// Idempotent single insert with ON CONFLICT DO NOTHING
// Used in batch operations - duplicates silently ignored based on UNIQUE(recurring_template_id, occurs_at)
func (q *Queries) InsertItemIgnoreConflict(ctx context.Context, arg InsertItemIgnoreConflictParams) error {
	_, err := q.db.Exec(ctx, insertItemIgnoreConflict,
		arg.ID,
		arg.ListID,
		arg.Title,
		arg.Status,
		arg.Priority,
		arg.EstimatedDuration,
		arg.ActualDuration,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DueAt,
		arg.Tags,
		arg.RecurringTemplateID,
		arg.StartsAt,
		arg.OccursAt,
		arg.DueOffset,
		arg.Timezone,
		arg.Version,
	)
	return err
}

const listTasksWithFilters = `-- name: ListTasksWithFilters :many
SELECT i.id, i.list_id, i.title, i.status, i.priority, i.estimated_duration, i.actual_duration, i.created_at, i.updated_at, i.due_at, i.tags, i.recurring_template_id, i.starts_at, i.occurs_at, i.due_offset, i.timezone, i.version, COUNT(*) OVER() AS total_count
FROM todo_items i
LEFT JOIN recurring_template_exceptions e
    ON i.recurring_template_id = e.template_id
    AND i.occurs_at = e.occurs_at
WHERE
    e.id IS NULL AND  -- Exclude items with exceptions
    ($1::uuid = '00000000-0000-0000-0000-000000000000' OR i.list_id = $1) AND
    (array_length($2::text[], 1) IS NULL OR i.status = ANY($2::text[])) AND
    (array_length($12::text[], 1) IS NULL OR i.status != ALL($12::text[])) AND
    (array_length($3::text[], 1) IS NULL OR i.priority = ANY($3::text[])) AND
    (array_length($4::text[], 1) IS NULL OR i.tags @> $4::text[]) AND
    ($5::timestamptz = '0001-01-01 00:00:00+00' OR i.due_at <= $5) AND
    ($6::timestamptz = '0001-01-01 00:00:00+00' OR i.due_at >= $6) AND
    ($7::timestamptz = '0001-01-01 00:00:00+00' OR i.updated_at >= $7) AND
    ($8::timestamptz = '0001-01-01 00:00:00+00' OR i.created_at >= $8)
ORDER BY
    -- due_at: default ASC
    CASE WHEN $9::text IN ('due_at', 'due_at_asc') THEN i.due_at END ASC NULLS LAST,
    CASE WHEN $9::text = 'due_at_desc' THEN i.due_at END DESC NULLS LAST,
    -- priority: default ASC (semantic order: low=1 < medium=2 < high=3 < urgent=4)
    -- Uses numeric weights instead of lexical ordering to match proto enum semantics
    CASE WHEN $9::text IN ('priority', 'priority_asc') THEN
        CASE i.priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END ASC NULLS LAST,
    CASE WHEN $9::text = 'priority_desc' THEN
        CASE i.priority
            WHEN 'low' THEN 1
            WHEN 'medium' THEN 2
            WHEN 'high' THEN 3
            WHEN 'urgent' THEN 4
        END
    END DESC NULLS LAST,
    -- created_at: default DESC
    CASE WHEN $9::text = 'created_at_asc' THEN i.created_at END ASC,
    CASE WHEN $9::text IN ('created_at', 'created_at_desc') THEN i.created_at END DESC,
    -- updated_at: default DESC
    CASE WHEN $9::text = 'updated_at_asc' THEN i.updated_at END ASC,
    CASE WHEN $9::text IN ('updated_at', 'updated_at_desc') THEN i.updated_at END DESC,
    -- Fallback: created_at DESC (when no valid order_by specified)
    i.created_at DESC
LIMIT $10
OFFSET $11
`

type ListTasksWithFiltersParams struct {
	Column1  pgtype.UUID        `json:"column_1"`
	Column2  []string           `json:"column_2"`
	Column3  []string           `json:"column_3"`
	Column4  []string           `json:"column_4"`
	Column5  pgtype.Timestamptz `json:"column_5"`
	Column6  pgtype.Timestamptz `json:"column_6"`
	Column7  pgtype.Timestamptz `json:"column_7"`
	Column8  pgtype.Timestamptz `json:"column_8"`
	Column9  string             `json:"column_9"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
	Column12 []string           `json:"column_12"`
}

type ListTasksWithFiltersRow struct {
	ID                  string             `json:"id"`
	ListID              string             `json:"list_id"`
	Title               string             `json:"title"`
	Status              string             `json:"status"`
	Priority            sql.Null[string]   `json:"priority"`
	EstimatedDuration   pgtype.Interval    `json:"estimated_duration"`
	ActualDuration      pgtype.Interval    `json:"actual_duration"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           time.Time          `json:"updated_at"`
	DueAt               pgtype.Timestamptz `json:"due_at"`
	Tags                []string           `json:"tags"`
	RecurringTemplateID uuid.NullUUID      `json:"recurring_template_id"`
	StartsAt            pgtype.Date        `json:"starts_at"`
	OccursAt            pgtype.Timestamptz `json:"occurs_at"`
	DueOffset           pgtype.Interval    `json:"due_offset"`
	Timezone            sql.Null[string]   `json:"timezone"`
	Version             int32              `json:"version"`
	TotalCount          int64              `json:"total_count"`
}

// Optimized for SEARCH/FILTER access pattern: Database-level filtering, sorting, and pagination.
// Performance: Pushes all operations to PostgreSQL with proper indexes vs loading all items to memory.
// Use case: Task search, filtered views, "My Tasks" views, pagination through large result sets.
//
// Parameters (use empty arrays for NULL to skip filters):
//
//	$1: list_id           - Filter by specific list (zero UUID to search all lists)
//	$2: statuses          - Array of statuses to include (empty array to skip, OR logic)
//	$3: priorities        - Array of priorities to include (empty array to skip, OR logic)
//	$4: tags              - Array of tags to match (empty array to skip, item must have ALL tags)
//	$5: due_before        - Filter tasks due before timestamp (zero time to skip)
//	$6: due_after         - Filter tasks due after timestamp (zero time to skip)
//	$7: updated_at        - Filter by last update time (zero time to skip)
//	$8: created_at        - Filter by creation time (zero time to skip)
//	$9: order_by          - Combined field+direction: 'due_at_asc', 'due_at_desc', etc.
//	                        Supports: due_at, priority, created_at, updated_at with _asc or _desc suffix
//	                        For bare field names, defaults are: due_at=asc, priority=asc,
//	                        created_at=desc, updated_at=desc
//	$10: limit            - Page size (max items to return)
//	$11: offset           - Pagination offset (skip N items)
//	$12: excluded_statuses - Array of statuses to exclude (empty array to skip filter)
//	                        Used to exclude archived/cancelled by default when $2 is empty
//
// Returns: All todo_items columns plus total_count (total matching rows across all pages)
// The COUNT(*) OVER() window function computes total matching rows in a single query pass,
// enabling accurate pagination UI without a separate count query.
//
// SQL Injection Protection:
// The ORDER BY clause uses parameterized queries ($9::text) with CASE expressions.
// PostgreSQL's parameterized query protocol treats $9 as DATA, never CODE, making SQL
// injection structurally impossible. Even if malicious input like "id; DROP TABLE--"
// flows through without validation, it's compared as a string literal in CASE expressions,
// never executed as SQL. This protection is guaranteed by PostgreSQL's wire protocol.
// See tests/integration/sql_injection_resistance_test.go for proof.
//
// Input validation at the service layer improves UX (clear error messages) but does NOT
// provide security - parameterized queries are the security boundary.
//
// Access pattern examples:
//   - "Show my overdue tasks": filter by due_before=now, order by due_at_asc
//   - "Active work": statuses=[todo, in_progress], default sort
//   - "High priority items": priorities=[high, urgent], order by due_at_asc
//   - "Tasks tagged 'urgent' and 'work'": tags=[urgent, work] (item must have both)
func (q *Queries) ListTasksWithFilters(ctx context.Context, arg ListTasksWithFiltersParams) ([]ListTasksWithFiltersRow, error) {
	rows, err := q.db.Query(ctx, listTasksWithFilters,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Column7,
		arg.Column8,
		arg.Column9,
		arg.Limit,
		arg.Offset,
		arg.Column12,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTasksWithFiltersRow{}
	for rows.Next() {
		var i ListTasksWithFiltersRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.Title,
			&i.Status,
			&i.Priority,
			&i.EstimatedDuration,
			&i.ActualDuration,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DueAt,
			&i.Tags,
			&i.RecurringTemplateID,
			&i.StartsAt,
			&i.OccursAt,
			&i.DueOffset,
			&i.Timezone,
			&i.Version,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTodoItem = `-- name: UpdateTodoItem :one
UPDATE todo_items
SET title = CASE WHEN $1::boolean THEN $2 ELSE title END,
    status = CASE WHEN $3::boolean THEN $4 ELSE status END,
    priority = CASE WHEN $5::boolean THEN $6 ELSE priority END,
    estimated_duration = CASE WHEN $7::boolean THEN $8 ELSE estimated_duration END,
    actual_duration = CASE WHEN $9::boolean THEN $10 ELSE actual_duration END,
    due_at = CASE WHEN $11::boolean THEN $12 ELSE due_at END,
    starts_at = CASE WHEN $13::boolean THEN $14 ELSE starts_at END,
    due_offset = CASE WHEN $15::boolean THEN $16 ELSE due_offset END,
    tags = CASE WHEN $17::boolean THEN $18 ELSE tags END,
    timezone = CASE WHEN $19::boolean THEN $20 ELSE timezone END,
    recurring_template_id = CASE WHEN $21::boolean THEN NULL ELSE recurring_template_id END,
    updated_at = NOW(),
    version = version + 1
WHERE id = $22
  AND list_id = $23
  AND ($24::integer IS NULL OR version = $24::integer)
RETURNING id, list_id, title, status, priority, estimated_duration, actual_duration, created_at, updated_at, due_at, tags, recurring_template_id, starts_at, occurs_at, due_offset, timezone, version
`

type UpdateTodoItemParams struct {
	SetTitle             bool               `json:"set_title"`
	Title                string             `json:"title"`
	SetStatus            bool               `json:"set_status"`
	Status               sql.Null[string]   `json:"status"`
	SetPriority          bool               `json:"set_priority"`
	Priority             sql.Null[string]   `json:"priority"`
	SetEstimatedDuration bool               `json:"set_estimated_duration"`
	EstimatedDuration    pgtype.Interval    `json:"estimated_duration"`
	SetActualDuration    bool               `json:"set_actual_duration"`
	ActualDuration       pgtype.Interval    `json:"actual_duration"`
	SetDueAt             bool               `json:"set_due_at"`
	DueAt                pgtype.Timestamptz `json:"due_at"`
	SetStartsAt          bool               `json:"set_starts_at"`
	StartsAt             pgtype.Date        `json:"starts_at"`
	SetDueOffset         bool               `json:"set_due_offset"`
	DueOffset            pgtype.Interval    `json:"due_offset"`
	SetTags              bool               `json:"set_tags"`
	Tags                 []string           `json:"tags"`
	SetTimezone          bool               `json:"set_timezone"`
	Timezone             sql.Null[string]   `json:"timezone"`
	DetachFromTemplate   bool               `json:"detach_from_template"`
	ID                   string             `json:"id"`
	ListID               string             `json:"list_id"`
	ExpectedVersion      pgtype.Int4        `json:"expected_version"`
}

// DATA ACCESS PATTERN: Partial update with explicit flags
// Supports field masks by passing boolean flags for fields to update
// Returns updated row, or pgx.ErrNoRows if:
//   - Item doesn't exist
//   - Item belongs to different list (security: prevents cross-list updates)
//   - Version mismatch (concurrency: prevents lost updates)
//
// SECURITY: Validates item belongs to the specified list
// CONCURRENCY: Optional version check for optimistic locking
// TYPE SAFETY: All fields managed by sqlc - schema changes caught at compile time
func (q *Queries) UpdateTodoItem(ctx context.Context, arg UpdateTodoItemParams) (TodoItem, error) {
	row := q.db.QueryRow(ctx, updateTodoItem,
		arg.SetTitle,
		arg.Title,
		arg.SetStatus,
		arg.Status,
		arg.SetPriority,
		arg.Priority,
		arg.SetEstimatedDuration,
		arg.EstimatedDuration,
		arg.SetActualDuration,
		arg.ActualDuration,
		arg.SetDueAt,
		arg.DueAt,
		arg.SetStartsAt,
		arg.StartsAt,
		arg.SetDueOffset,
		arg.DueOffset,
		arg.SetTags,
		arg.Tags,
		arg.SetTimezone,
		arg.Timezone,
		arg.DetachFromTemplate,
		arg.ID,
		arg.ListID,
		arg.ExpectedVersion,
	)
	var i TodoItem
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.Title,
		&i.Status,
		&i.Priority,
		&i.EstimatedDuration,
		&i.ActualDuration,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DueAt,
		&i.Tags,
		&i.RecurringTemplateID,
		&i.StartsAt,
		&i.OccursAt,
		&i.DueOffset,
		&i.Timezone,
		&i.Version,
	)
	return i, err
}

const updateTodoItemStatus = `-- name: UpdateTodoItemStatus :execrows
UPDATE todo_items
SET status = $1, updated_at = $2
WHERE id = $3
`

type UpdateTodoItemStatusParams struct {
	Status    string    `json:"status"`
	UpdatedAt time.Time `json:"updated_at"`
	ID        string    `json:"id"`
}

// DATA ACCESS PATTERN: Single-query existence check via rowsAffected
// :execrows returns (int64, error) - Repository checks rowsAffected == 0 → domain.ErrNotFound
// Efficient status updates without separate existence check
func (q *Queries) UpdateTodoItemStatus(ctx context.Context, arg UpdateTodoItemStatusParams) (int64, error) {
	result, err := q.db.Exec(ctx, updateTodoItemStatus, arg.Status, arg.UpdatedAt, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
