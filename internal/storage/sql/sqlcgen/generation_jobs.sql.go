// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: generation_jobs.sql

package sqlcgen

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createGenerationJob = `-- name: CreateGenerationJob :exec
INSERT INTO recurring_generation_jobs (
    id, template_id, scheduled_for, status,
    generate_from, generate_until, created_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateGenerationJobParams struct {
	ID            uuid.UUID `json:"id"`
	TemplateID    uuid.UUID `json:"template_id"`
	ScheduledFor  time.Time `json:"scheduled_for"`
	Status        string    `json:"status"`
	GenerateFrom  time.Time `json:"generate_from"`
	GenerateUntil time.Time `json:"generate_until"`
	CreatedAt     time.Time `json:"created_at"`
}

func (q *Queries) CreateGenerationJob(ctx context.Context, arg CreateGenerationJobParams) error {
	_, err := q.db.ExecContext(ctx, createGenerationJob,
		arg.ID,
		arg.TemplateID,
		arg.ScheduledFor,
		arg.Status,
		arg.GenerateFrom,
		arg.GenerateUntil,
		arg.CreatedAt,
	)
	return err
}

const deleteCompletedGenerationJobs = `-- name: DeleteCompletedGenerationJobs :exec
DELETE FROM recurring_generation_jobs
WHERE status = 'COMPLETED' AND completed_at < $1
`

func (q *Queries) DeleteCompletedGenerationJobs(ctx context.Context, completedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedGenerationJobs, completedAt)
	return err
}

const getGenerationJob = `-- name: GetGenerationJob :one
SELECT id, template_id, scheduled_for, started_at, completed_at, failed_at, status, error_message, retry_count, generate_from, generate_until, created_at FROM recurring_generation_jobs
WHERE id = $1
`

func (q *Queries) GetGenerationJob(ctx context.Context, id uuid.UUID) (RecurringGenerationJob, error) {
	row := q.db.QueryRowContext(ctx, getGenerationJob, id)
	var i RecurringGenerationJob
	err := row.Scan(
		&i.ID,
		&i.TemplateID,
		&i.ScheduledFor,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.Status,
		&i.ErrorMessage,
		&i.RetryCount,
		&i.GenerateFrom,
		&i.GenerateUntil,
		&i.CreatedAt,
	)
	return i, err
}

const listPendingGenerationJobs = `-- name: ListPendingGenerationJobs :many
SELECT id, template_id, scheduled_for, started_at, completed_at, failed_at, status, error_message, retry_count, generate_from, generate_until, created_at FROM recurring_generation_jobs
WHERE status = 'PENDING' AND scheduled_for <= $1
ORDER BY scheduled_for ASC
LIMIT $2
`

type ListPendingGenerationJobsParams struct {
	ScheduledFor time.Time `json:"scheduled_for"`
	Limit        int32     `json:"limit"`
}

func (q *Queries) ListPendingGenerationJobs(ctx context.Context, arg ListPendingGenerationJobsParams) ([]RecurringGenerationJob, error) {
	rows, err := q.db.QueryContext(ctx, listPendingGenerationJobs, arg.ScheduledFor, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RecurringGenerationJob{}
	for rows.Next() {
		var i RecurringGenerationJob
		if err := rows.Scan(
			&i.ID,
			&i.TemplateID,
			&i.ScheduledFor,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.Status,
			&i.ErrorMessage,
			&i.RetryCount,
			&i.GenerateFrom,
			&i.GenerateUntil,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGenerationJobStatus = `-- name: UpdateGenerationJobStatus :exec
UPDATE recurring_generation_jobs
SET status = $1,
    started_at = CASE WHEN $1 = 'RUNNING' THEN $2 ELSE started_at END,
    completed_at = CASE WHEN $1 = 'COMPLETED' THEN $2 ELSE completed_at END,
    failed_at = CASE WHEN $1 = 'FAILED' THEN $2 ELSE failed_at END,
    error_message = $3,
    retry_count = $4
WHERE id = $5
`

type UpdateGenerationJobStatusParams struct {
	Status       string         `json:"status"`
	StartedAt    sql.NullTime   `json:"started_at"`
	ErrorMessage sql.NullString `json:"error_message"`
	RetryCount   int32          `json:"retry_count"`
	ID           uuid.UUID      `json:"id"`
}

func (q *Queries) UpdateGenerationJobStatus(ctx context.Context, arg UpdateGenerationJobStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateGenerationJobStatus,
		arg.Status,
		arg.StartedAt,
		arg.ErrorMessage,
		arg.RetryCount,
		arg.ID,
	)
	return err
}
